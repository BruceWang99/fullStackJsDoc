## 上海迈科技
### 一面笔试
#### 输入正整数，找到0到这个正整数所有带1的数，返回找到所有数的个数
```javascript
// 剑指 Offer 43. 1～n 整数中 1 出现的次数
function countOnes (n) {
  let count = 0;
  function findOne(n) {
    // 短除法, 找出每一位是不是1
    while (n >= 10) {
      const c = Math.floor(n / 10);
      const y = n % 10;
      if (c >= 10) {
        if (y === 1) {
          count++;
        };
      } else {
        if (y === 1) {
          count++;
        }
      }
      n = c;
    }
    if (n === 1) {
      count++;
    }
  }
  // 遍历所有的值
  for (let i = 1; i <= n; i++) {
    findOne(i);
  }
  return count;
}
console.log(countOnes(13));
```
#### flex实现：在一个固定高度的盒子里，有两个div，第一个div在上面，高度固定，宽度100%，
第二个div在下面，高度不固定，宽度100%，实现第一个div内容很多很多时，高度固定，自动滚动
#### Vue3 TypeScript写一个组件
### 二面技术面
#### 说下常见的排序算法以及他们的算法复杂度
排序封装的util
```javascript
 const Compare = {
    LESS_THAN: -1,
    BIGGER_THAN: 1,
    EQUALS: 0
  };
  function defaultCompare(a, b) {
    if (a === b) {
      return Compare.EQUALS;
    }
    return a < b ? Compare.LESS_THAN : Compare.BIGGER_THAN;
  }
  function swap(array, a, b) {
    /* const temp = array[a];
    array[a] = array[b];
    array[b] = temp; */
    [array[a], array[b]] = [array[b], array[a]];
  }
  module.exports = {
    Compare,
    defaultCompare,
    swap
  }
```
### 冒泡排序

-  双遍历 + 数据交换 
-  算法性能 
   - 时间复杂度 O(n^2)
-  思路
   - 把两层遍历
   - 比较相邻元素的的大小, 如果第一个比第二个大, 就交换他们
```javascript
// 冒泡排序
const  { Compare, defaultCompare, swap } = 	require('../util');
function bubbleSort(array, compareFn = defaultCompare) {
  const { length } = array;
  for (let i = 0; i < length; i++) {
    for (let j = 0; j < length - 1 - i; j++) {
      if (compareFn(array[j], array[j + 1]) === Compare.BIGGER_THAN) {
        swap(array, j, j + 1);
      }
    }
  }
  return array;
}

console.log(bubbleSort([1,4,25,5,34,8]))

```
### 选择排序

-  双遍历 + 最小值 + 数据交换 
-  算法性能 
   - 时间复杂度 O(n^2)
-  思路 
   - 找到数据结构中的最小值, 并放置在第一位
   - 接着找第二小的值放在第二位
```javascript
// 选择排序
const { Compare, defaultCompare, swap } = require('../util');

const selectionSort = (array, compareFn = defaultCompare) => {
  const { length } = array;
  let indexMin;
  for (let i = 0; i < length - 1; i++) {
    indexMin = i;
    // console.log('index ' + array[i]);
    for (let j = i; j < length; j++) {
      if (compareFn(array[indexMin], array[j]) === Compare.BIGGER_THAN) {
        // console.log('new index min ' + array[j]);
        indexMin = j;
      }
    }
    if (i !== indexMin) {
      // console.log('swap ' + array[i] + ' with ' + array[indexMin]);
      swap(array, i, indexMin);
    }
  }
  return array;
};
console.log(selectionSort([1,4,25,5,34,8]))
```
### 插入排序

-  遍历 + 向前位插入 
-  算法性能 
   - 排序小数组, 比选择和冒泡好
-  思路 
   - 从数组第二位开始遍历整个数组
   - 把当前位的值和前面位的值对比, 如果当前位的值要小于前面位的值, 就把当前位的值赋值为前面位的值
   - 当前位的值要大于前面位的值, 把当前位插入到前面位的位置上
```javascript
// 插入排序
const  { Compare, defaultCompare } = 	require('../util');

const insertionSort = (array, compareFn = defaultCompare) => {
  const { length } = array;
  let temp;
  for (let i = 1; i < length; i++) {
    let j = i;
    temp = array[i];
    // console.log('to be inserted ' + temp);
    while (j > 0 && compareFn(array[j - 1], temp) === Compare.BIGGER_THAN) {
      // console.log('shift ' + array[j - 1]);
      array[j] = array[j - 1];
      j--;
    }
    // console.log('insert ' + temp);
    array[j] = temp;
  }
  return array;
};

console.log(insertionSort([1,4,25,5,34,8]))

```
### 归并排序

-  递归分治 + 有序队列的合并 
-  算法性能 
   - O(nlog(n))
-  Array.prototype.sort中Firefox使用了 
-  思路 
   - 把一个数组从中间切成两个子数组, 递归切分到只有一个元素
   - 再把有序的子数组合并
   - 直到全部合并成一个数组
```javascript
// 归并排序
const  { Compare, defaultCompare } = 	require('../util');

function merge(left, right, compareFn) {
  let i = 0;
  let j = 0;
  const result = [];
  while (i < left.length && j < right.length) {
    result.push(compareFn(left[i], right[j]) === Compare.LESS_THAN ? left[i++] : right[j++]);
  }
  return result.concat(i < left.length ? left.slice(i) : right.slice(j));
}
function mergeSort(array, compareFn = defaultCompare) {
  if (array.length > 1) {
    const { length } = array;
    const middle = Math.floor(length / 2);
    const left = mergeSort(array.slice(0, middle), compareFn);
    const right = mergeSort(array.slice(middle, length), compareFn);
    array = merge(left, right, compareFn);
  }
  return array;
}

console.log(mergeSort([1,4,25,5,34,8]))

```
### 快速排序

-  递归分治 + 数据交换 + 双指针 
-  算法性能 
   - 时间复杂度 O(nlogn)
   - 性能通常比其他复杂度为O(nlog(n))的排序算法要好
-  简单思路 
   - 在数据集之中，选择一个元素作为"基准"
   - 所有小于"基准"的元素，都移到"基准"的左边；所有大于"基准"的元素，都移到"基准"的右边
   - 对"基准"左边和右边的两个子集，不断重复第一步和第二步，直到所有子集只剩下一个元素为止。
-  具体思路 
   - 在数据集之中，选中间的元素为"基准"（pivot）
   - 基准位一边的头和尾各放一个索引
   - 左边的值小于“基准”, 则移动左边的索引
   - 右边的值大于“基准”, 则移动右边的索引
   - 不是上面两种, 就交换 两边的值, 同时移动两边的索引
   - 重复递归
```javascript
// 快速排序
const  { Compare, defaultCompare, swap } = 	require('../util');
// 把数组分成以“基准”分成两边, 一边大于“基准”, 一边小于“基准”, 最后返回基准的索引, 用于做下一次的数组切割
function partition(array, left, right, compareFn) {
  const pivot = array[Math.floor((right + left) / 2)];
  let i = left;
  let j = right;

  while (i <= j) {
	// 左边的值小于“基准”, 则移动左边的索引
    while (compareFn(array[i], pivot) === Compare.LESS_THAN) {
      i++;
    }
	// 右边的值大于“基准”, 则移动右边的索引
    while (compareFn(array[j], pivot) === Compare.BIGGER_THAN) {
      j--;
    }
	// 不是上面两种, 就交换 两边的值
    if (i <= j) {
      swap(array, i, j);
      i++;
      j--;
    }
  }
  return i;
}
function quick(array, left, right, compareFn) {
  let index;
  if (array.length > 1) {
    index = partition(array, left, right, compareFn);
    if (left < index - 1) {
      quick(array, left, index - 1, compareFn);
    }
    if (index < right) {
      quick(array, index, right, compareFn);
    }
  }
  return array;
}
function quickSort(array, compareFn = defaultCompare) {
  return quick(array, 0, array.length - 1, compareFn);
}

console.log(quickSort([1,4,25,5,34,8]))

```
#### 快排的实现思路

- 在数据集之中，选择一个元素作为"基准"
- 所有小于"基准"的元素，都移到"基准"的左边；所有大于"基准"的元素，都移到"基准"的右边
- 对"基准"左边和右边的两个子集，不断重复第一步和第二步，直到所有子集只剩下一个元素为止。
#### 快排的最差情况时间复杂度为什么是**n²**呢? 
每一次取到的元素就是数组中最小/最大的((每一次都排好一个元素的顺序)
#### interface和type的区别

- 接口创建了一个名字和接口类型, Type只是一个别名, 引用了一些类型
- 类型别名不能被extends和implements
#### 说下 交叉类型和联合类型
& 交叉类型是将多个类型合并为一个类型, 交叉类型中所有类型的条件都要满足
|  联合类型是将多个类型合并为一个类型,  联合类型的所有类型的条件满足其中一个就行
#### 知不知道索引类型怎么定义
索引类型查询操作符（keyof T）
> 表示类型T所有公共属性(key)的字面量的联合类型

```javascript
function getValues<T, K extends keyof T>(person: T, keys: K[]): T[K][] {
  return keys.map(key => person[key]);
}
interface Person {
    name: string;
    age: number;
}

const person: Person = {
    name: 'musion',
    age: 35
}

getValues(person, ['name']) // ['musion']
getValues(person, ['gender']) // 报错
```
上述代码解析:
K extends keyof T: K继承T的所有属性(key), 这里是 name属性、age属性
T[K]: 索引访问(类似于对象的属性访问), getValues(person, ['name'])中指的是string(Person['name'])
K extends T表示泛型约束
#### 说下keyof的含义
表示获取类型所有的属性(key), 返回的是一个联合类型, 可以搭配in操作符使用
```javascript
// 将传入的属性变为只读选项
type Readonly<T> = {
    readonly [P in keyof T]: T[P];
}
// 将传入的属性变为可选项：keyof T 拿到 T 所有属性名, 然后 in 进行遍历, 将值赋给 P, 最后 T[P] 取得相应属性的值.
type Partial<T> = {
    [P in keyof T]?: T[P];
}
// 将K中的所有属性的值转化为T类型：
type Record<K extends keyof any, T> = { [P in K]: T };
// 从 T 中取出 一系列 K 的属性
type Pick<T, K extends keyof T> = { [P in K]: T[P] };
// 将传入的属性变为必选项
type Required<T> = { [P in keyof T]-?: T[P] };
```

上述代码解析:
P in keyof T: p是遍历出来的T的属性(key)
#### TypeScript和Java的静态类型的区别
#### 说下 any和unknown的区别
any:
不清楚类型的变量, 跳过类型约束
unknown:
  1.  所有类型都可以分配给unknown

2. 只能被赋值给 any和unknown 
#### Vue3 composition api的好处

- 相同逻辑代码的复用
- 减小了代码体积
- 没有 this 的烦恼
#### vue3 setup的变量，怎么能应用到template中使用?

- 加载组件时, 从组件选项中取出setup函数
- 调用setup函数, 把组件实例的props和setupContext做为参数, 保存调用后的结果setupState
- 最后在Proxy数据代理的时候, get、set把普通的state、props、setupState做赋值和获取值
#### 有没有写过webpack loader或者是webpack plugin
实现一个markdown-loader
```javascript
const marked = require('marked')

module.exports = source => {
  const html = marked(source)
  // 返回 html 字符串交给下一个 loader 处理
  return html
}
```
```javascript
const path = require('path')

module.exports = {
  mode: 'none',
  entry: './src/main.js',
  output: {
    filename: 'bundle.js',
    path: path.join(__dirname, 'dist'),
    publicPath: 'dist/'
  },
  module: {
    rules: [
      {
        test: /.md$/,
        use: [
          'html-loader',
          './markdown-loader'
        ]
      }
    ]
  }
}
```
实现一个删除注释的Plugin
> 相比Loader, Plugin 有更宽的能力范围,几乎可以触及到webpack工作的每一个环节

- hooks (钩子机制)

        emit钩子: 当webpack将要往文件目录输出文件之前执行
       done钩子: 在 compilation 完成时执行

- compiler
webpack 编译器实例, 有hooks、run、watch等属性、方法
- compilation

        所有打包的结果都放到这个对象当中, 此次打包的上下文
```javascript
class MyPlugin {
  // compiler => webpack 编译器实例, 有hooks、run、watch等属性、方法
  apply (compiler) {
    console.log('MyPlugin 启动')
    compiler.hooks.emit.tap('MyPlugin', compilation => {
      // compilation => 可以理解为此次打包的上下文
      for (const name in compilation.assets) {
        console.log(name)
        console.log(compilation.assets[name].source())
        if (name.endsWith('.js')) {
          const contents = compilation.assets[name].source()
          // 替换注释
          const withoutComments = contents.replace(/\/\*\*+\*\//g, '')
          compilation.assets[name] = {
            source: () => withoutComments, // 替换内容
            size: () => withoutComments.length // 内容大小
          }
        }
      }
    })
  }
}
```




## 七猫小说

平时是通过什么方式学习，最近印象比较深刻的是什么文章
### 平时是通过什么方式学习，最近印象比较深刻的是什么文章

- 看书
- 文档
- 视频
- 博客
- 直播
### 知道微前端么？

- single-spa
- qiankun(基于 single-spa 做了二次开发)
- webpack5 模块联邦, 跨应用模块共享
 new ModuleFederationPlugin
### 低代码了解么？

- 用可视化方式创建应用的平台
- 拖拽拼凑生成代码
### 服务端渲染了解么
首先要说下客户端渲染、服务端渲染、同构渲染三者的关系
客户端渲染 : 普通的spa
服务端渲染 : 像以前的PHP直接用模版引擎组装html,再返回到客户端
同构渲染: 

- 同样一套代码, 既可以运行在服务端也可以运行在客户端
- 服务端渲染整个页面
- 客户端渲染
_在html中提取服务器发送过来的数据,用来初始化整个Vue.js(事件绑定这些)
_把已经渲染的DOM元素和vue组件渲染的虚拟DOM建立联系

应用框架的话:
_ Vue：Nuxt.js
_ React：Next.js
### pwa了解么？
渐进式的web app
Service Worker + CacheStorage + HTTPS
注册 -> 安装 -> 触发activate事件执行操作 -> 触发fetch事件缓存请求
### http 与 https是如何校验的
![image.png](https://cdn.nlark.com/yuque/0/2022/png/1184187/1658967451467-09c7a58f-6aeb-449b-8b31-6db8f1f43e43.png#averageHue=%23f5eae0&clientId=u83e2944c-587c-4&errorMessage=unknown%20error&from=paste&height=550&id=u005a8a61&name=image.png&originHeight=777&originWidth=828&originalType=binary&ratio=1&rotation=0&showTitle=false&size=332832&status=error&style=none&taskId=u5f66569d-a2f9-42d6-aae1-c49cdc90160&title=&width=586)
一句话:
TSL握手时, 用非对称算法加密(RSA), 传输时使用对称加密算法加密(AES等)
后四次握手:

- 客户端发送请求,并告诉服务端当前客户端所支持的加密组件和压缩算法
- 服务端选择加密组件和压缩算法,并返回证书给客户端, 证书包含公钥, 私钥由服务端保存
- 客户端会对服务端证书进行校验, 如果不合法, 就会警告, 合法的话生成随机数, 并有公钥加密随机数,发给服务端
- 服务端通过私钥解密随机数, 告诉客户端以后的通信都按协商好的随机数的对称加密对数据加密
### http2了解么，优缺点有哪些
优点:

- 二进制分帧
头信息和数据体都是二进制
请求和相应数据分割为更小的帧，用二进制编码
HTTP/2 使用了数据流的概念，因为 HTTP/2 的数据包是不按顺序发送的，同一个连接里面连续的数据包，可能属于不同的请求。因此，必须要对数据包做标记，指出它属于哪个请求
- 多路复用
在一个连接里，客户端和服务器都可以同时发送多个请求或回应，而且不用按照顺序一一发送
避免了"队头堵塞"
- 头部压缩
http2头信息使用 gzip 或 compress 压缩后再发送
客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段
- 服务器推送
HTTP2 允许服务器未经请求，主动向客户端发送资源
使用服务器推送提前给客户端推送必要的资源(静态资源)，这样就可以相对减少一些延迟时间

缺陷:
TCP 以及 TCP+TLS 建立连接的延时
  TCP 连接需要和服务器进行**三次握手**，即消耗完 1.5 个 RTT 之后才能进行数据传输。
TCP 的队头阻塞并没有彻底解决
  TCP 为了保证可靠传输，有一个“超时重传”机制，丢失的包必须等待重传确认。HTTP2 出现丢包时，整个 TCP 都要等待重传，那么就会阻塞该 TCP 连接中的所有请求。
多路复用导致服务器压力上升
  多路复用没有限制同时请求数。请求的平均数量与往常相同，但实际会有许多请求的短暂爆发，导致瞬时 QPS 暴增。
多路复用容易 Timeout
  大批量的请求同时发送，由于 HTTP2 连接内存在多个并行的流，而网络带宽和服务器资源有限，每个流的资源会被稀释，虽然它们开始时间相差更短，但却都可能超时。
### 常用的数组方法，foreach怎么跳出循环，聊聊some，every方法区别
不建议使用forEach跳出循环, 是不规矩的写法, 可以使用 for of 或者for
硬是要跳出循环, 可以**通过抛出异常的方式跳出循环**
some
数组中只要有一个元素通过被提供的函数测试
every
数组中所有有一个元素通过被提供的函数测试
### settimeout和setInterval区别，运行时间长setInterval可能会不准，为什么
根源在于浏览器的事件循环机制
### 平时在工作中用到哪些算法
用到多的主要是排序
### 常见排序算法有哪些
冒泡、选择、插入、归并、快排
### 快排的优缺点
优点: 平均性能好, 算法时间复杂度是n(log(n)), 比冒泡这些排序快
缺点：不稳定，初始序列有序或基本有序时，时间复杂度降为O(n^2)
### js深拷贝做法，JSON.stringify()的问题
简单熟悉的数据结构可以使用:
JSON.stringify()
标准的深拷贝可以借助lodash工具库提供的方法
这种深拷贝的实现:

```javascript
// 1. 函数 undefined symbol 不能复制
// 2. ** 循环引用拷贝会报错
// JSON.parse(JSON.stringify(obj))
// https://juejin.cn/post/6844903929705136141

function getType (b) {
	return Object.prototype.toString.call(b)
}
const isObject = function(b) {
	return getType(b) === '[object Object]'
}
const isMap = function(b) {
	return getType(b) === '[object Map]'
}
const isSet = function(b) {
	return getType(b) === '[object Set]'
}
function cloneDeep(obj, map = new WeakMap()) {
	let o = null
	if(obj instanceof Object) { // 引用类型
		if(map.has(obj)) return map.get(obj)
		let cloneObj = null
		o = new obj.constructor()
		map.set(obj, o)  // 解决循环应用 key value 弱引用, value 可随时被垃圾回收
		if(isObject(obj)) {	
			const keys =  Object.keys(obj)
			for (let key of keys) {
				o[key] = cloneDeep(obj[key], map)
			}
			return o
		} else if(Array.isArray(obj)){
			for (let key in obj) {
				o[key] = cloneDeep(obj[key], map)
			}
			return o
		} else if(isMap(obj)) {
			obj.forEach((value, key) => {
				o.set(key, cloneDeep(value), map)	
			});
			return o
		} else if(isSet(obj)) {
			obj.forEach(value => {
				o.add(cloneDeep(value), map)	
			});
			return o
		} else if(typeof obj === 'function') {
			return obj
		} else { // 其他类型
			return obj
		}
	} else { // 原始类型
		return obj
	}
}


const target = {
    field1: 1,
    field2: undefined,
    field3: 'ConardLi',
    field4: {
        child: 'child',
        child2: {
            child2: 'child2'
        }
    },
	field5: new Map([[1, 2], [3, 4]]),
	field6: new Set('a', 'b', 'c'),
	field7: [1,2,3, {a: 1, b: 2}]
};
target.target = target
console.log(target);
console.log(cloneDeep(target));
```
### Less用的比较多的是什么
变量: @width: 10px; 
混合（Mixins）: .bordered(); 
嵌套（Nesting） 
运算（Operations）: @color: (#224488 / 2); // 结果是 #112244 
函数（Functions）: @width: 0.5; width: percentage(@width); // returns `50%` 
导入（Importing）: @import "typo.css";
### less数组定义的几种方式
@colors: red, green, blue, black;
获取数组元素长度
@length: length(@color);
数组元素取值
@item: extract(@colors, @index);
### less遍历数组的方法，区别
> 在Less中并没有对数组遍历的原生支持，我们可以通过mixin递归的方式来实现遍历。

```javascript
@colors: red, green, blue, black;
.for(@data, @i: 1) when(@i =< length(@data)) {
    @item: extract(@data, @i); // 找到数组指定位置的值
    div {
        background: @item;
    }
    .for(@data, (@i + 1));
}
.for(@colors);
```

- 实现一个mixin .for(), 定义两个参数 data和i
- 使用when关键词, 当i <= 数组的长度时, 遍历数组
- extract(@data, @i) 找到数组指定位置的值
- 写入一次循环要做的样式
- 遍历下一个值
### sass %的含义？混入指令？控制指令？
```javascript
%toolbelt {
  box-sizing: border-box;
  border-top: 1px rgba(#000, .12) solid;
  padding: 16px 0;
  width: 100%;
  &:hover { border: 2px rgba(#000, .5) solid; }
}

.action-buttons {
  @extend %toolbelt;
  color: #4285f4;
}

```
```javascript
@mixin sexy-border($color, $width) {
  border: {
    color: $color;
    width: $width;
    style: dashed;
  }
}
p { @include sexy-border(blue, 1in); }
```
```javascript
 p{
    @if 1 + 1 == 2 { width: 20px }
}
```
```javascript
@for $num from 1 through 3 {
  .item{
    width:$num * 3px;
  }
}
```
```javascript
$i: 6;
@while $i > 0 {
  .item-#{$i} { width: 2em * $i; }
  $i: $i - 2;
}
```
```javascript
each $animal in puma, sea-slug, egret, salamander {
  .#{$animal}-icon {
    background-image: url('/images/#{$animal}.png');
  }
}
```
### 怎么做项目选型？
1、从项目角度：
看项目的需求，项目的规模，重要程度，以及项目结点时间等，项目的重要性和紧急程度，很大程度上会制约我们对于技术选型的考虑，这种情况下，我们一般不会用新出来的工具或者比较不成熟的设计（上线后的迭代里，可以把这些融进去）
2、团队的因素
团队的规模，团队同学都习惯什么技术栈，在选型的时候，这块的成本也要考虑进去，不然有可能学习试错的成本比实际开发时间都要长
3、现有人力和能调用的资源
比如同时进行的还有几个也很重要的项目，可做新项目的同学不多，那这个时候也要考虑是否能以架构先稳当一点，内部的特性或功能部分尝试新的工具，哪怕是在打包或者编译的地方用新的也可以
4、技术角度
（1）框架考虑，结合能否用便捷的模板开发，vue和react虽然思想不太一样，但不应该对立，可能只是短期学习上会有差距
（2）框架选定后，看项目的实际情况，决定是否可以用开源的ui库，或者自建ui库
（3）数据状态管理工具，是否需要，怎么维护数据
（4）异步请求库的选择，axios一般能满足绝大部分场景了
（5）是否需要node中间层
（6）移动端项目，还可能会有ssr，埋点监控等
（7）项目缓存，离线化
### 移动端在ios和安卓上，日期表现有兼容性，兼容性问题是什么？
ios不支持 - 解决方法: 全部替换 /
### 
ios端的键盘和输入框位置的问题
可以失焦的时候对比前后的innerHeight, 如果不相同,scrollTo做下偏移
### ios和安卓滚动事件srcoll，表现不一样却别在哪
不同机型 onscroll 事件触发情况：
body 滚动

- _ios 不能实时触发_
- ios wkwebview 内核 实时触发
- android 实时触发

局部滚动

- _ios 不能实时触发_
- ios wkwebview 内核 实时触发
- android 实时触发

 滚动惯性
-webkit-overflow-scrolling
滚动样式
移动端滚动样式，可以使用CSS伪类选择器::-webkit-scrollbar控制一个元素的滚动条的样式
仅仅在支持WebKit的浏览器 (例如, 谷歌Chrome, 苹果Safari)
 ● ::-webkit-scrollbar — 整个滚动条.
 ● ::-webkit-scrollbar-button — 滚动条上的按钮 (上下箭头). 
● ::-webkit-scrollbar-thumb — 滚动条上的滚动滑块. 
● ::-webkit-scrollbar-track — 滚动条轨道. 
● ::-webkit-scrollbar-track-piece — 滚动条没有滑块的轨道部分.
 ● ::-webkit-scrollbar-corner — 当同时有垂直滚动条和水平滚动条时交汇的部分. 
● ::-webkit-resizer — 某些元素的corner部分的部分样式(例:textarea的可拖动按钮).
模拟滚动 (iscroll)

- 监听滚动元素的 touchmove 事件，当事件触发时修改元素的 transform 属性来实现元素的位移，让手指离开时触发 touchend 事件，然后采用 requestanimationframe 来在一个线型函数下不断的修改元素的 transform 来实现手指离开时的一段惯性滚动距离
- 监听滚动元素的 touchmove 事件，当事件触发时修改元素的 transform 属性来实现元素的位移，让手指离开时触发 touchend 事件，然后给元素一个 css 的 animation，并设置好 duration 和 function 来实现手指离开时的一段惯性距离
### 1px问题出现的原因，和解决办法
物理像素和逻辑像素的区别
### 移动端适配方案是什么

- rem
- vw
### root fontsize计算公式是什么？
设计稿是宽750px来做的，书写css方便计算考虑，根节点的font-size假定为100px，得出设备宽为7.5rem。
根节点的font-size=设备宽度/7.5。// 一个单位的宽度
document.documentElement.style.fontSize = document.documentElement.clientWidth * (window.devicePixelRatio||1) / 7.5 + 'px';
### 做过什么项目上的性能优化

- webpack
- cdn
- 图片
- 本地缓存
- css + js
- gzip
### 服务端给了1w条数据，怎么优化展示

- 分页加载
- 时间分片 requestAnimationFrame 或 requestIdleCallback 
- 虚拟列表
### 虚拟列表的实现方式

- 给每个列表项设置固定的高度，并根据列表项个数 * 单个列表项高度得出列表容器的可滚动高度；
- 计算列表容器的高度，并结合当个元素高度计算可挂载的元素数量；
- 监听容器滚动，计算已加载的元素总高度，当前视图所渲染的元素总高度以及可视区域底部未加载元素的总高度
### 在js中有一个方法，能知道某个元素是否离开屏幕，或是否在屏幕上显示
**Intersection Observer API** 会注册一个回调函数，每当被监视的元素进入或者退出另外一个元素时 (或者 viewport )，或者两个元素的相交部分大小发生变化时，该回调方法会被触发执行。
```javascript
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
    <script>
    </script>
</head>
<body>
    <div id="scrollArea" style="width: 300px; height: 300px;background: red;overflow: auto;">
      <div style="width: 300px; height: 400px;"></div>
      <div id="item" style="width: 100px; height: 100px;background: black;"></div>
    </div>
    <script>
        let options = {
          root: document.querySelector('#scrollArea'),
          rootMargin: '0px',
          threshold: 1.0
        }
        const callback = function (entries, observer) {
          console.log('IntersectionObserver的回调', entries, observer)
        }
        let observer = new IntersectionObserver(callback, options);
        let target = document.querySelector('#item');
        observer.observe(target);
    </script>
</body>
</html>
```
### 你们项目中的错误监控是怎么做的？
 买的阿里的ARMS前端监控
## 上海翼支付
### js继承的方式, class继承和ES5继承的区别
[https://www.yuque.com/aimee1608/tw7w58/emz2xy](https://www.yuque.com/aimee1608/tw7w58/emz2xy)
[https://github.com/mqyqingfeng/Blog/issues/16](https://github.com/mqyqingfeng/Blog/issues/16)
#### 六大继承方式
#### 1.原型链继承
```javascript
function Parent() {
  this.name = 'kevin';
}

Parent.prototype.getName = function () {
  console.log(this.name);
}
function Child() {

}
Child.prototype = new Parent();
var child1 = new Child();
console.log(child1.getName());
```
问题：
1.引用类型的属性被所有实例共享，举个例子：
```javascript
function Parent () {
    this.names = ['kevin', 'daisy'];
}

function Child () {

}

Child.prototype = new Parent();

var child1 = new Child();

child1.names.push('yayu');

console.log(child1.names); // ["kevin", "daisy", "yayu"]

var child2 = new Child();

console.log(child2.names); // ["kevin", "daisy", "yayu"]
```
2.在创建 Child 的实例时，不能向Parent传参
#### 2.借用构造函数(经典继承)
```javascript
function Parent () {
    this.names = ['kevin', 'daisy'];
}

function Child () {
    Parent.call(this);
}

var child1 = new Child();

child1.names.push('yayu');

console.log(child1.names); // ["kevin", "daisy", "yayu"]

var child2 = new Child();

console.log(child2.names); // ["kevin", "daisy"]
```
优点：
1.避免了引用类型的属性被所有实例共享
2.可以在 Child 中向 Parent 传参
举个例子：
```javascript
function Parent (name) {
    this.name = name;
}

function Child (name) {
    Parent.call(this, name);
}

var child1 = new Child('kevin');

console.log(child1.name); // kevin

var child2 = new Child('daisy');

console.log(child2.name); // daisy
```

缺点：
方法都在构造函数中定义，每次创建实例都会创建一遍方法。
#### 3.组合继承
原型链继承和经典继承双剑合璧。
```javascript
function Parent (name) {
    this.name = name;
    this.colors = ['red', 'blue', 'green'];
}

Parent.prototype.getName = function () {
    console.log(this.name)
}

function Child (name, age) {

    Parent.call(this, name);
    
    this.age = age;

}

Child.prototype = new Parent();
// 此处如果不变constructor new 之后的实例是Parent 只是显示不一样
Child.prototype.constructor = Child;

var child1 = new Child('kevin', '18');

child1.colors.push('black');

console.log(child1.name); // kevin
console.log(child1.age); // 18
console.log(child1.colors); // ["red", "blue", "green", "black"]

var child2 = new Child('daisy', '20');

console.log(child2.name); // daisy
console.log(child2.age); // 20
console.log(child2.colors); // ["red", "blue", "green"]
```
优点：融合原型链继承和构造函数的优点，是 JavaScript 中最常用的继承模式。
#### 4.原型式继承
```javascript
function createObj(o) {
    function F(){}
    F.prototype = o;
    return new F();
}
```

就是 ES5 Object.create 的模拟实现，将传入的对象作为创建的对象的原型。
缺点：
包含引用类型的属性值始终都会共享相应的值，这点跟原型链继承一样。

```javascript
var person = {
    name: 'kevin',
    friends: ['daisy', 'kelly']
}

var person1 = createObj(person);
var person2 = createObj(person);

person1.name = 'person1';
console.log(person2.name); // kevin

person1.friends.push('taylor');
console.log(person2.friends); // ["daisy", "kelly", "taylor"]
```
注意：修改person1.name的值，person2.name的值并未发生改变，并不是因为person1和person2有独立的 name 值，而是因为person1.name = 'person1'，给person1添加了 name 值，并非修改了原型上的 name 值。
#### 5. 寄生式继承
创建一个仅用于封装继承过程的函数，该函数在内部以某种形式来做增强对象，最后返回对象。
```javascript
function createObj (o) {
    var clone = Object.create(o);
    clone.sayName = function () {
        console.log('hi');
    }
    return clone;
}
```
缺点：跟借用构造函数模式一样，每次创建对象都会创建一遍方法。
#### 6. 寄生组合式继承
为了方便大家阅读，在这里重复一下组合继承的代码：
```javascript
function Parent (name) {
    this.name = name;
    this.colors = ['red', 'blue', 'green'];
}

Parent.prototype.getName = function () {
    console.log(this.name)
}

function Child (name, age) {
    Parent.call(this, name);
    this.age = age;
}

Child.prototype = new Parent();

var child1 = new Child('kevin', '18');

console.log(child1)
```
组合继承最大的缺点是会调用两次父构造函数。
一次是设置子类型实例的原型的时候：
```javascript
Child.prototype = new Parent();
```
一次在创建子类型实例的时候：
```javascript
var child1 = new Child('kevin', '18');
```
回想下 new 的模拟实现，其实在这句中，我们会执行：
```javascript
Parent.call(this, name);
```
在这里，我们又会调用了一次 Parent 构造函数。
所以，在这个例子中，如果我们打印 child1 对象，我们会发现 Child.prototype 和 child1 都有一个属性为colors，属性值为['red', 'blue', 'green']。
那么我们该如何精益求精，避免这一次重复调用呢？
如果我们不使用 Child.prototype = new Parent() ，而是间接的让 Child.prototype 访问到 Parent.prototype 呢？
看看如何实现：
```javascript
function Parent (name) {
    this.name = name;
    this.colors = ['red', 'blue', 'green'];
}

Parent.prototype.getName = function () {
    console.log(this.name)
}

function Child (name, age) {
    Parent.call(this, name);
    this.age = age;
}

// 关键的三步
var F = function () {};

F.prototype = Parent.prototype;

Child.prototype = new F();


var child1 = new Child('kevin', '18');

console.log(child1);
```
最后我们封装一下这个继承方法：
```javascript
function object(o) {
    function F() {}
    F.prototype = o;
    return new F();
}

function prototype(child, parent) {
    var prototype = object(parent.prototype);
    prototype.constructor = child;
    child.prototype = prototype;
}

// 当我们使用的时候：
prototype(Child, Parent);
```
引用《JavaScript高级程序设计》中对寄生组合式继承的夸赞就是：
这种方式的高效率体现它只调用了一次 Parent 构造函数，并且因此避免了在 Parent.prototype 上面创建不必要的、多余的属性。与此同时，原型链还能保持不变；因此，还能够正常使用 instanceof 和 isPrototypeOf。开发人员普遍认为寄生组合式继承是引用类型最理想的继承范式。
ES6 的class可以看作只是一个语法糖，它的绝大部分功能，ES5 都可以做到，新的class写法只是让对象原型的写法更加清晰、更像面向对象编程的语法
#### 用法

1. constructor()方法默认返回实例对象（即this），完全可以指定返回另外一个对象。
2. 父类的静态方法，可以被子类继承。
3. 静态方法也是可以从super对象上调用
4. #x, 用#开头定义私有属性和方法(ES2022)
#### 区别

- 类**必须使用 new 来调用**，否则会报错。这是他跟普通构造函数的一个主要区别，后者不用 new 也可以执行。
- 类内**不存在变量提升**，这一点与ES5完全不同。
- 类和模块的内部，默认就是**严格模式**，所以不需要使用use strict指定运行模式
### class 继承 怎么继承父类的私有属性, super关键字的作用
继承父类的私有属性不要继承!!!, 不然还叫什么私有属性
#### js中私有属性实现的几种方式
(1) TypeScript的private属性, 私有属性是不允许继承的
(2) [ES2022](https://github.com/tc39/proposal-class-fields)正式为class添加了私有属性，方法是在属性名之前使用#表示。
(3) 在命名上加以区别, 比如_bar, 缺点是类的外部，还是可以调用到这个方法
(4) 索性将私有方法移出类，因为类内部的所有方法都是对外可见
```javascript
class Widget {
  foo (baz) { // foo是公开方法，内部调用了bar.call(this, baz)。这使得bar()实际上成为了当前类的私有方法。
    bar.call(this, baz);
  }
}

function bar(baz) {
  return this.snaf = baz;
}
```

(5) 利用Symbol值的唯一性，将私有方法的名字命名为一个Symbol值, 缺点: Reflect.ownKeys()依然可以拿到它们。
```javascript
const bar = Symbol('bar');
const snaf = Symbol('snaf');

export default class myClass{
  // 公有方法
  foo(baz) {
    this[bar](baz);
  }
  // 私有方法
  [bar](baz) {
    return this[snaf] = baz;
  }
};
```
#### super关键字的作用
(1) super()执行**父类的构造函数**
(2) super() 返回的是**子类的实例**，即 super 内部的 this 指向的是B，此时 super() 相当于 A.prototype.constructor.call(this)
```javascript
class A {
  constructor() {
    console.log(new.target.name); //new.target指向当前正在执行的函数
  }
}
class B extends A {
  constructor() {
    super();
  }
}
new A() // A
new B() // B
```
 (3) **当作对象使用**时, 普通方法中，指向父类的原型对象；super在静态方法中调用, 指向的是父类
```javascript
class A {
  static s() {
    console.log('super调用静态方法, 指向的是父类');
  }
  constructor() {
    this.x = 1;
  }
  c() {
    return 2;
  }
}
class B extends A {
  constructor() {
    super();
    console.log(super.c()); // 2
    console.log(super.x); // undefined  super在普通方法中调用，指向父类的原型对象
  }
  static toS() {
    console.log(super.s()); // super在静态方法中调用, 指向的是父类
  }
}
let b = new B();
B.toS()
```
#### super的要求

- 只可以在派生类中使用super。派生类是指继承自其它类的新类
- 在构造函数中访问this之前要调用super()，负责初始化this
- 如果不想调用super，可以让类的构造函数返回一个对象
### requestAnimationFrame是怎么使用的


requestAnimationFrame函数，如果你希望执行一个动画，并且要求浏览器在下次重绘前执行指定的回调函数来更新动画，该方法需要传一个回调函数作为参数，会在浏览器下次重绘前执行回调函数。
浏览器FPS通常为60, 即一秒刷新60次，requestAnimationFrame 每次调用间隔为16.7ms。
requestAnimationFrame只会调用一次传入的函数，所以每次更新用户界面时需要再手动调用它一次。 
目前为止，requestAnimationFrame已经解决了浏览器不知道 JavaScript 动画何时开始的问题， 以及最佳间隔是多少的问题，但是，不知道自己的代码何时实际执行的问题呢?这个方案同样也给出了 解决方法。
传给 requestAnimationFrame()的函数实际上可以接收一个参数，**此参数是一个 DOMHighRes- TimeStamp 的实例(比如 performance.now()返回的值)，表示开始去执行回调函数的时刻**。这一点非常重要: requestAnimationFrame()实际上把重绘任务安排在了未来一个已知的时间点上，而且通过这个参数 告诉了开发者。基于这个参数，就可以更好地决定如何调优动画了。

```javascript
<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Document</title>
	<style>
		#some-element-you-want-to-animate {
			width: 100px;
			height: 100px;
			background-color: red;
		}
	</style>
</head>
<body>
	<div id="some-element-you-want-to-animate"></div>
	<script>
		window.onload = function() {
		    console.log('onload');
			const element = document.getElementById('some-element-you-want-to-animate');
			let start;

			function step(timestamp) {
			  if (start === undefined)
			    start = timestamp;
			  const elapsed = timestamp - start;

			  //这里使用`Math.min()`确保元素刚好停在200px的位置。
			  element.style.transform = 'translateX(' + Math.min(0.1 * elapsed, 200) + 'px)';

			  if (elapsed < 2000) { // 在两秒后停止动画
			    window.requestAnimationFrame(step);
			  }
			}
			window.requestAnimationFrame(step);
		}
	</script>
</body>
</html>
```

#### 优点

- requestAnimationFrame会把每一帧中的所有DOM操作集中起来，在一次重绘或回流中就完成
- 在隐藏或不可见的元素中，requestAnimationFrame将不会进行重绘或回流，这当然就意味着更少的CPU、GPU和内存使用量
- requestAnimationFrame是由浏览器专门为动画提供的API，在运行时浏览器会自动优化方法的调用，并且如果页面不后台运行，动画会自动暂停，有效节省了CPU开销
#### 对比setInterval和setTimeout

- setInterval和setTimeout循环的**时间不精确**, 浏览器的计时器精度不足
- setInterval和setTimeout**更多的重绘或回流**
#### 为什么有时候用 setTimeout 替代 setInterval?

- setInterval会使得前后两次定时器代码的执行间隔产生不可预料的变化
> 对每个时间间隔把回调推入宏任务队列中, 前面同步代码的执行和微任务的执行超过这个时间间隔时, 会导致时间间隔变长还会导致后面的间隔时间变短, setTimeout至少不会导致间隔的时间变短, 只会变长

### vue2中 重写了数组的哪些方法
> 重写了数组的push、pop、shift、unshift、splice、sort、reverse七种方法

还通过执行ob.dep.notify()将当前数组的变更通知给其订阅者，这样当使用重写后方法改变数组后，数组订阅者会将这边变化更新到页面中。
### react类组件中为什么要使用bind 绑定this

- 事件处理程序方法会**丢失其隐式绑定的上下文**
- 当事件被触发并且处理程序被调用时，this的值会回退到**默认绑定**，即值为 undefined

react 自己定义了一套事件系统(Synthetic Event)

- 兼容各种主流浏览器的DOM事件
- 事件池机制
1. SyntheticEvent对象会被缓存且反复使用，目的是提高性能，减少创建不必要的对象。
2. 同时带来了不能异步使用的弊端 ,可以**及时缓存所需的event属性值来解决**
```javascript
mport React, { Component } from "react";

class TextInput extends Component {
  state = {
    editionCounter: 0,
    value: this.props.defaultValue,
  }
  // 由于 setState 是异步操作，event.target.value 在运行时可能已经被重置了
  handleChange = event => 
    // const value = event.target.value 这样解决
    this.setState(prevState => ({ value: event.target.value, editionCounter: prevState.editionCounter + 1 }));

  render() {
    return (
      <span>Edited {this.state.editionCounter} times</span>
      <input
        type="text"
        value={this.state.value}
        onChange={this.handleChange} // WRONG!
      />
    )
  }
}
```
React合成事件原理: 
事件委托，也就是事件代理机制，这种机制不会把事件处理函数绑定到真是的DOM节点上，而是把所有事件绑定在结构最外层，使用一个统一的事件监听和处理函数
```javascript
 <!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
    <script>
    </script>
</head>
<body>
    <ul id="list">
      <li>item 1</li>
      <li>item 2</li>
      <li>item 3</li>
      <li>item n</li>
    </ul>
    <script>
        // 给父层元素绑定事件
        document.getElementById('list').addEventListener('click', function (e) {
          // 兼容性处理
          var event = e || window.event;
          var target = event.target || event.srcElement;
          // 判断是否匹配目标元素
          if (target.nodeName.toLocaleLowerCase() === 'li') {
            console.log('the content is: ', target.innerHTML);
          }
        });
    </script>
</body>
</html>
```
### call、apply、bind的区别

- 参数
call和bind 是从第二个参数起
apply 第二个参数是数组
- 是否立即执行

bind不立即执行
### 手写一个bind, 怎么实现
一个关键点: **this 指向的是函数调用的地方**
在**要绑定的上下文上加一个中间属性**, 这个属性赋值为这个函数, 再调用这个上下文上的属性, 再删除这个属性
`context.fn = this  context.fn(...argu) `
```javascript
Function.prototype.myBind = function(context) {
	if(typeof this !== 'function') {
		throw new Error('不是一个函数')
	}
	context.fn = this
	return function (...argu) {
		return context.fn(...argu)
	}
}
```
```javascript
Function.prototype.myApply = function (context, arr = []) {
	if(typeof this !== 'function') {
		throw new Error('不是函数')
	}
	context = context || window
	context.fn = this
	const result = context.fn(...arr)
	delete context.fn
	return result
}
```
```javascript
Function.prototype.myCall = function (context, ...arr) {
	if(typeof this !== 'function') {
		throw new Error('不是函数')
	}
	context = context || window
	context.fn = this
	const result = context.fn(...arr)
	delete context.fn
	return result
}
```
### vue的响应式数据原理

-  vue2 
   -  数据代理 
      -  Observer 
         -  深层代理数据 
            - 递归
         -  Object.defineProperty 
            -  configurable 
               - 该属性的描述符才能够被改变，同时该属性也能从对应的对象上被删除。
            -  enumerable 
               - 会出现在对象的枚举属性中
         -  用get和set方法监听对象属性的变化 
            - get时依赖收集
            - set时通知更新
   -  观察者模式 
      -  Dep 
         - 发布者
         - 每个属性放一个Dep实例
      -  Watcher 
         -  观察者 
         -  创建时订阅发布者 
            - Dep.target
         -  更新视图 
-  vue3 
   -  表现和大致原理基本相同 
   -  剥离出一套完整的响应式系统, 可以脱离框架使用 
   -  数据代理 
      -  ES6的Proxy实现 
         - 避免了vue早期版本的问题
   -  收集依赖 
      -  track 
         -  targetMap 
            - 存储整个响应式目标的依赖
         -  depsMap 
            - 存储很多个不同依赖的空间
         -  dep(Set) 
            - 存储相同依赖的不同位置, 都是一个独一不二的值
   -  触发更新 
      -  trigger 
         - 对应的targetMap中的depsMap的dep
         - 遍历所有的回调函数
   -  响应式主要的api 
      -  reactive 
         - 类似放在template中data的响应式
      -  ref 
         - 可以给原始值加响应式
         - 对象直接走reactive
      -  toRefs 
         - reactive中的属性转ref
         - 解构reactive很适用
      -  readonly 
         - 防止更改响应式对象
      -  watchEffect 
         - 立即执行传入的一个函数，同时响应式追踪其依赖
### react和vue的区别

-  相同 
   -  都属于声明式而非命令式的框架或库 
      - 声明式注重结果
      - 命令式注重过程
   -  组件化 
   -  跨平台 
      - 都使用了Virtual DOM + Diff算法
-  区别 
   -  定位 
      -  vue 渐进式 JavaScript 框架 
         - 由浅入深, 易学易用
      -  react 构建UI的 javascript库 
         - 聚焦构建UI
   -  设计思想(运行时、编译时) 
      -  React  重运行时 
         -  JSX通过babel转换为React.createElement, 执行后生成jsx对象 
         -  经过Scheduler的调度, 把任务优先级排序 
            - requsetIdlCallback
         -  在Reconciler的调解, 比较jsx和当前Fiber节点的差异 
            - diff对比
         -  经过Renderer的处理, 这些副作用应用到真实节点 
      -  vue 编译时 + 运行时 
         - 把模版编译成render函数体(放在vue的核心中)
         - 调用render函数, 生成虚拟DOM
         - 对比DOM节点, 更新差异到页面
      -  Svelte 重编译时 
         - 直接把HTML字符串编译成命令式代码
   -  数据更新 
      -  vue 靶向更新, 精确到组件级别而不会更新该组件内的子组件 
         - 每个组件都有自己的渲染 watcher，它掌管了当前组件的视图更新，但是并不会掌管 ChildComponent 的更新
      -  react自顶向下的进行递归更新 
         -  React 中假如 ChildComponent 里还有十层嵌套子元素，那么所有层次都会递归的重新render 
         -  遵从Immutable的设计思想，永远不在原对象上修改属性 
         -  优化 
            - React 创造了Fiber，创造了异步渲染
            - memo和shouldComponentUpdate这些优化手段
   -  template和JSX 
      -  Vue 
         - 偏视觉的组件用template
         - 偏逻辑的组件用JSX
      -  React 
         - 灵活
   -  diff算法实现 
      -  思想相同 
         - 子主题 1
   -  事件机制 
-  选型 
   -  vue 
      - 在开发效率和普通业务逻辑的项目更优
      - 在性能上有追求, 又不想过多处理的项目更优
   -  react 
      - 有更为复杂业务逻辑和复用问题的项目更优
      - 有更优秀的技术团队和经验者更优
      - 想在代码上更好的创造力上更优
   -  对于有vue 和react的开发老鸟以上可以忽略 
### 项目中遇到的有什么难点, 能说下吗?

- 富文本内容的多行省略功能

解决原理:
1. 使用Selection API , 根据实际视觉内容截断多行文本 (window.getSelection())
```javascript
 <!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
    <script>
    </script>
</head>
<body>
    <p id="truncate2" class="truncated">
        <b>Google LLC</b><sup id="cite_ref-5" class="reference"><a href="#cite_note-5">[5]</a></sup> is an American <a href="/wiki/Multinational_corporation" title="Multinational corporation">multinational</a> <img id="truncate2-img" src="//upload.wikimedia.org/wikipedia/commons/thumb/2/2f/Google_2015_logo.svg/250px-Google_2015_logo.svg.png"/> <a href="/wiki/Technology_company" title="Technology company">technology company</a> that specializes in <a href="/wiki/Internet" title="Internet">Internet</a>-related services and products.
    </p>
    <script src="https://rawgit.com/zhengrenzhe/shear.js/master/dist/shear.js"></script>
    <script>
        shear(document.getElementById('truncate2'), 1, '<span>... (more)</span>');
    </script>
</body>
</html>
```
主要原理:
第一种:
遍历要循环的行数, 使用**selection.modify**("extend", "right", "lineboundary") 选区选中一行
第二种(如果selection.modify不支持):
所有的文本节点, 创建一个**range对象**(document.createRange()), 把每一个文本节点放到range中, **判断range的height和之前的高度不一致的时候, 就多一行**

- H5视频全屏功能的样式统一和全屏兼容问题
> 结合mediaelement, 使用position和transform, 模拟全屏功能, 磨平系统全屏样式

不管视频是长视频还是短视频, 全部竖直全屏, 统一样式操作
### 说下事件循环

-  协调各类事件 
   - 用户交互
   - 脚本
   - 渲染
   - 网络请求
-  Event Loop在浏览器中有几种, window event loop、worker event loop、worklet event loop, 主要说window event loop 
-  一直监听任务队列的任务,有任务,就去执行 
-  执行栈 
-  任务队列(宏任务队列) 
   - 一系列任务的集合
-  微任务队列 
   - 先进先出
-  宏任务 
   - BOM/node相关的事件操作
   - setTimeout\setInterval
   - I/O (用户点击交互)
   - UI rendering (浏览器独有)
   - setImmediate (node、IE 实现了)
   - requestAnimationFrame (浏览器独有)
   - requestIdleCallback (浏览器独有)
-  微任务 
   -  Promise (then，catch，finally) 
   -  MutationObserver 
      - DOM发生变化时被调用
   -  process.nextTick (Node独有) 
      - 本次事件循环执行后，在下一次事件循环前调用
   -  Object.observe  (废弃) 
-  一次执行顺序 
   -  执行第一个可执行的宏任务 
      - 宏任务队列
   -  执行最早的微任务,直到全部执行完 
      - 微任务队列
   -  requestAnimationFrame 
      - 重绘前执行这个回调
   -  根据渲染时机绘制页面 
      - 屏幕刷新频率60Hz( 16.66ms)）
   -  requestIdleCallback 
      - 在浏览器空闲时期被调用
      - 回调参数有个空闲时间
-  node的事件循环机制 
   -  node有6个队列 主要是4个宏任务队列和2个微任务队列 
      -  2个微任务队列 
         -  next tick queue 
            - process.nextTick
         -  other queue 
         -  从上到下执行 
      -  4个宏任务队列 
         -  timers queue 
            - setTImeout
         -  io callbacks queue 
            -  fs 
               - readFile
         -  check queue 
            -  setImmediate 
               - 一些需要长时间运行的操作放在一个回调函数里
         -  close callbacks queue 
            - server.close
            - socket.on('close', ...)
         -  从上到下执行 
   -  node 清空完一个宏任务队列, 就执行微任务队列, 再清空第二个. (node 按一个宏任务队列为单位)浏览器执行完所有的微任务, 放一个宏任务, 再执行执行所有微任务, 再放一个宏任务(浏览器 按一个宏任务为单位) 
### 说下Promise、async await 和setTimeout的区别?
async await优势: 

- 同步方式写异步代码
- 直接用try/catch处理错误
- 调试友好, 直接在函数内debugger

setTimeout是宏任务, 没什么太多的可比性
### 说下vuex的理解

-  原理 
   -  在Vue上放一个全局的对象, 这个对象来维护应用的状态 
   -  状态响应式 
   -  单向数据流 
      - 方便跟踪每一个状态的变化
-  功能 
   -  state 
   -  getters 
      - 从 Vue 3.0 开始，getter 的结果不再像计算属性一样会被缓存起来。
   -  mutations 
      - commit
   -  action 
      - dispatch
      - 可以包含任意异步操作
      - 提交的是 mutation
### vuex和redux的区别
> 基本思想是相同的, 都注重状态的可预测性 (单一数据源、单向数据流动)

- redux注重不可变性, vuex注重数据的自动响应
## 万得
### 一面

- 自我介绍
- 根据简历询问项目经历和解决方法
### 二面笔试
笔试题: [购物网站 - L2 - 1h.pdf](https://liuliuliu.yuque.com/attachments/yuque/0/2022/pdf/1184187/1659489610004-3301e3ad-1098-4b71-97cb-5606060f6bb2.pdf?_lake_card=%7B%22src%22%3A%22https%3A%2F%2Fliuliuliu.yuque.com%2Fattachments%2Fyuque%2F0%2F2022%2Fpdf%2F1184187%2F1659489610004-3301e3ad-1098-4b71-97cb-5606060f6bb2.pdf%22%2C%22name%22%3A%22%E8%B4%AD%E7%89%A9%E7%BD%91%E7%AB%99%20-%20L2%20-%201h.pdf%22%2C%22size%22%3A618890%2C%22ext%22%3A%22pdf%22%2C%22source%22%3A%22%22%2C%22status%22%3A%22done%22%2C%22download%22%3Atrue%2C%22type%22%3A%22application%2Fpdf%22%2C%22mode%22%3A%22title%22%2C%22taskId%22%3A%22u464f1858-9996-40a9-b28c-152df8bfb37%22%2C%22taskType%22%3A%22upload%22%2C%22__spacing%22%3A%22both%22%2C%22id%22%3A%22gxJuD%22%2C%22margin%22%3A%7B%22top%22%3Atrue%2C%22bottom%22%3Atrue%7D%2C%22card%22%3A%22file%22%7D)
实现: [https://bluenote.oss-cn-shanghai.aliyuncs.com/my-cart.zip](https://bluenote.oss-cn-shanghai.aliyuncs.com/my-cart.zip)
### 三面面试
看简历问项目上的问题
## 晨曦股份
### 一面笔试
1、使用css画一个三角形？
使用border边框的一边去调试
```
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
    <style>
        .triangle {
		    border-top: 20px solid #fff;
		    border-right: 20px solid black;
		    border-bottom: 20px solid #fff;
		    width: 0;
		}
    </style>
    <script>
    </script>
</head>
<body>
    <div class="triangle" ></div>
</body>
</html>
```
2、var、let、const 区别?

- 块级作用域 : let、const
- 暂存性死区: let、const
- 是否需要初始值: let、const
- const指向的内存地址不允许修改
- 是否变量提升: var
- 是否会升级为全局变量: var

3、说说你对闭包的理解？闭包使用场景
闭包: 引用了不属于当前作用域的变量, 这些引用把当前作用域包围
写一个常用的闭包:

```javascript
function a () {
  let b = 1;
  return function () {
    console.log(b)
  }
}
```

使用场景:

- 函数柯里化
- 防止全局变量污染

缺点:

- 使用不当容易内存泄漏 
- 代码可读性

4、深拷贝浅拷贝的区别？
深拷贝:  原始类型和引用类型的各层的完全cope
1. JSON.parse(JSON.stringfiy(obj)) (循环引用、某些类型转化失败)
2. 递归遍历
浅拷贝: 原始类型和引用类型地址的一层cope
1. {...obj}
2. Object.assgin({}, obj1, obj2)
5、JavaScript中内存泄漏的几种情况？

- 不恰当的闭包
- 没有及时清理的定时器
- 遗忘的未引用的DOM

6、Vue导航守卫的钩子函数有哪些？
全局的导航守卫:
beforeEach 这个用的多 
单个路由的导航守卫:
路由进入的时候
路由离开的时候
7、Vue中key是用来做什么的？为什么不推介使用index作为key？
key最主要的作用是在diff比较的时候, 判断是不是相同的节点
index 会变, 不是唯一的值, 会导致页面渲染问题
8、为什么使用虚拟DOM 

- 保证页面性能的下限
- 使用数据驱动视图, 让开发者专注于业务逻辑
- 跨平台

9、MVC和MVVM的区别
MVC
Model View Controler
数据模型 视图 控制器
MVVM
Model View ViewModel
数据模型 视图  数据和视图的桥梁
10、说一下http和https的区别
主要是https的四大优势

- 多路复用
- 二进制分帧
- 服务端推送
- 头部压缩

https的缺点;

- 头部压缩还是没有完全做到很好
- 多路复用会给服务器带来更大的压力

11、什么是跨域？如何解决跨域？
CORS: 
要说到浏览器的同源策略
协议 host port 都有相同, 否则浏览器会爆验证错误
本地:
webpack的porxy
chrome 配置允许跨域的访问
服务端: 
1. 设置响应头, 允许客户端的请求

2.  ng 反向代理

12、手写一个函数使用setTimeout 模拟实现 setInterval
```javascript
function test () {
  setTimeout(()=> {
    console.log('这里循环啦')
    test()
  }, 500)
}

```

13，请写出下列js执行的结果，并简述原因
```javascript
setTimeout(function () {
console.log("1");
}, 0); // 宏任务
async function async1() {
console.log("2"); //  同步代码
const data = await async2();
console.log("3");
return data;
} // 函数声明
async function async2() {
return new Promise((resolve) => {
console.log("4"); // 同步代码
resolve("async2的结果");
}).then((data) => {
console.log("5");
return data;
});
} // 函数声明
async1().then((data) => {
console.log("6");
console.log(data);
});
new Promise(function (resolve) {
console.log("7"); // 同步代码
//   resolve()
}).then(function () {
console.log("8"); // 不会执行
});

同步代码:
2  4  7
微任务:
5 3 6 async2的结果
宏任务:
1
```
### 二面
#### Promise中所有的请求都要成功,  再去做某些逻辑?
`Promise.all`方法可以完成并行任务， 它接收一个数组，数组的每一项都是一个`promise`对象。当数组中所有的`promise`的状态都达到`resolved`的时候，`all`方法的状态就会变成`resolved`，如果有一个状态变成了`rejected`，那么`all`方法的状态就会变成`rejected`。
**如果报错, 返回的错误信息是第一个报错的Promise的错误信息**
```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
    <script>
    </script>
  </head>
  <body>
    <script>
      let p1 = new Promise(function(resolve, reject) {
        resolve(11)
      })
      let p2 = new Promise(function(resolve, reject){
        setTimeout(()=> {
          reject(22)
        },1000)
      })
      let p3 = new Promise(function (resolve, reject) {
        setTimeout(()=> {
          reject(33)
        },2000)
      })
      Promise.all([p1, p2, p3]).then(function(res) {
        console.log('res', res)
      }, function(err) {
        console.log('err', err)
      })
      // err 22
    </script>
  </body>
</html>
```
#### 说下事件冒泡和事件委托?
事件冒泡: 
从当前点击元素, 事件向外发散, 直到发散到最外层的DOM节点
阻止事件冒泡:  e.stopPropagation
一个题外话, 阻止事件的默认行为, 使用 e.preventDefault()
> 当前dom元素本来要做的行为, 如果 a标签点击要默认跳转, button submit 要默认提交这些


事件捕获:
从最外层的DOM节点, 向当前点击中心触发事件的过程
事件委托:
利用了事件冒泡，只指定一个事件处理程序，就可以管理某一类型的所有事件
#### 怎么样获取当前点击位置之外的所有的父级、祖先节点?
方法1: 递归
从当前点击节点一直向上找e.target.parentNode
方法2:直接获取当前节点的path
e.target.path
```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
    <script>
    </script>
  </head>
  <body>
    <div id = "1">
      <div id = "2">
        <div id = "3">
          <div id = "4">
            <div id = "5">
              <button id="btn">获取所有的父节点</button>
            </div>
          </div>
        </div>
      </div>
    </div>
    <script>
      function getParent(dom, result = []){
        if(dom.parentNode){
          result.push(dom.parentNode)
          return getParent(dom.parentNode, result);
        }
        return result;
      }
      document.getElementById("btn").addEventListener('click', function(event) {
        console.log(getParent(event.target))
        console.log(event.path)
      })
    </script>
  </body>
</html>
```
#### Vue中的组件通讯?

-  父子 
   - props/emit
   - $refs
   - provide/inject
-  兄弟 
   -  eventBus 
      - ![](https://g.yuque.com/gr/latex?emit%2F#card=math&code=emit%2F&id=JD7Rl)on、new Vue
   -  ![](https://g.yuque.com/gr/latex?parant%2F#card=math&code=parant%2F&id=oyxLA)refs 
-  任意组件 
   - eventBus
   - vuex
#### Vuex mutation和action的区别?

- action支持异步
- action不能直接操作State
#### Vue的初始化流程?
   [https://juejin.cn/post/6844903941721980936](https://juejin.cn/post/6844903941721980936)
![image.png](https://cdn.nlark.com/yuque/0/2022/png/1184187/1659705982406-ed8be045-1fa4-414d-8ac0-750d04b37c41.png#averageHue=%23f8ecce&clientId=u14d32f14-ff76-4&errorMessage=unknown%20error&from=paste&height=605&id=u42dbb91e&name=image.png&originHeight=756&originWidth=690&originalType=binary&ratio=1&rotation=0&showTitle=false&size=264193&status=error&style=none&taskId=u0c6fc4d9-d743-4242-89a0-221cc440ea9&title=&width=552)

-  把实例的生命周期、Vue事件、渲染的 一些属性初始化 
   - initLifecycle(vm)
initEvents(vm)
initRender(vm)
-  执行创建前钩子(beforeCreate) 
-  初始化实例状态 比如data、watch、computed、methods等 
   - 这里可以说vue的响应式系统
-  执行钩子(created) 
-  把模版转化为render函数 
   -  这里可以说Vue的编译原理 
      - 解析
      - 优化
      - 生成
-  执行beforeMounted 
-  虚拟DOM的解析并生成真实dom 
   -  调用render函数, 生成虚拟dom 
   -  调用patch函数对比新旧节点更新差异 
      - 把变化的Vnode更新到真实的DOM树 (createEle)
   -  这里可以说diff算法 
-  执行Mounted
## 携程
### 一面
#### Hybrid App有三种, 哪三种

1. 利用Web View插件或者其它框架为H5提供容器
2. react native、Flutter
3. 把页面直接打到app里
#### big.js的精度计算原理

-  二进制无限循环 
-  IEEE754 标准双精度浮点数(64位长度) 
   -  符号位 S 
      - 0正 1负
   -  阶码(指数位) E: 11 
      -  移码表示 
         -  原码 + 偏置值 
            -  E(原) = 移码 - 偏置值 
               -  偏置值 = 2^(n-1) - 1 
                  - n表示阶码位数
                  - 双精度: 2^(11-1) - 1 = 1024 - 1 = 1023
                  - 单精度: 2^(8-1) - 1  = 128 - 1 = 127
         -  补码的符号位取反 
            - 补码 = 反码  +1
      -  为什么用移码 
         -  便于浮点数比大小。 
            - 2^11(2048)个数中,去头尾: 2046个数, 一半正,一半负
            - 加上偏置值为 1023后, 指数全部为正, 并且没有符号位
         -  无符号正整数 
      -  计算的时候, 要用原码 
   -  尾数(数字位) M: 52 
      -  原码表示 
      -  规格化表示: 整数位为1 
         - 1<= M < 2, 即M的形式为1.xxxx的形式，xxx表示小数位
      -  舍去了第一位的1(一定是1), 实际上是53位 
   -  表示公式: V =  (-1)^s _ M _ 2^E 
      -  1011.1101 
      -  1.0111101 * 2^3 
      -  (-1)^0 _ 1.0111101 _ 2^3 
         - S = 0
         - M = 1.0111101
         - E = 3
   -  如果是索引数字或位运算是32位单精度 
      - 1位符号位
      - 后31位用于表示整数的值
   -  js能表示的最大数 
      -  阶码: 11111111110 
         - 11111111111 : 这个被NaN占用了
      -  尾数: 1.52个1 
      -  符号位是0 
      -  1.52个1  *  2^(11111111110的十进制 - 1023) 
   -  js最大的安全数(小数位超过52位的数字就失去准确了) 
      -  1.1111111111111111111111111111111111111111111111111111 * 2^52 
      -  不能大于53位表示的二进制 
         - 只能存储53位的数(不包含符号位)
-  将浮点数转为整数运算(number-precision) 
-  将浮点数转为字符串, 模拟运算(big.js) 
#### 虚拟列表实现原理, 怎么监听具体的滚动高度这些
截取长列表一部分数据用来填充可视区域
长列表数据不可视部分使用空白占位填充
监听滚动事件根据滚动位置动态改变可视列表
监听滚动事件根据滚动位置动态改变空白填充

#### webpack动态连接库的具体怎么来用的, 为什么不好用呢
##### 是什么
 用过 Windows 系统的人应该会经常看到以 .dll 为后缀的文件，这些文件称为**动态链接库**，在一个动态链接库中可以包含给其他模块调用的函数和数据。
##### Web 项目构建接入动态链接库的思想，需要完成以下事情：

- 把网页依赖的基础模块抽离出来，打包到一个个单独的动态链接库中去。一个动态链接库中可以包含多个模块。
- 当需要导入的模块存在于某个动态链接库中时，这个模块不能被再次被打包，而是去动态链接库中获取。
- 页面依赖的所有动态链接库需要被加载。
##### 具体的作用
提升构建速度
> 大量复用模块的动态链接库只需要编译一次，在之后的构建过程中被动态链接库包含的模块将不会在重新编译，而是直接使用动态链接库中的代码

##### 接入Webpack

- DllPlugin 插件：用于打包出一个个单独的动态链接库文件。
- DllReferencePlugin 插件：用于在主要配置文件中去引入 DllPlugin 插件打包好的动态链接库文件。
##### 构建出动态链接库文件
构建输出的以下这四个文件
├── polyfill.dll.js ├── polyfill.manifest.json ├── react.dll.js └── react.manifest.json 
和以下这一个文件
├── main.js 
是由两份不同的构建分别输出的。
动态链接库文件相关的文件需要由一份独立的构建输出，用于给主构建使用。新建一个 Webpack 配置文件 webpack_dll.config.js 专门用于构建它们，文件内容如下：
```javascript
const path = require('path');
const DllPlugin = require('webpack/lib/DllPlugin');

module.exports = {
  // JS 执行入口文件
  entry: {
    // 把 React 相关模块的放到一个单独的动态链接库
    react: ['react', 'react-dom'],
    // 把项目需要所有的 polyfill 放到一个单独的动态链接库
    polyfill: ['core-js/fn/object/assign', 'core-js/fn/promise', 'whatwg-fetch'],
  },
  output: {
    // 输出的动态链接库的文件名称，[name] 代表当前动态链接库的名称，
    // 也就是 entry 中配置的 react 和 polyfill
    filename: '[name].dll.js',
    // 输出的文件都放到 dist 目录下
    path: path.resolve(__dirname, 'dist'),
    // 存放动态链接库的全局变量名称，例如对应 react 来说就是 _dll_react
    // 之所以在前面加上 _dll_ 是为了防止全局变量冲突
    library: '_dll_[name]',
  },
  plugins: [
    // 接入 DllPlugin
    new DllPlugin({
      // 动态链接库的全局变量名称，需要和 output.library 中保持一致
      // 该字段的值也就是输出的 manifest.json 文件 中 name 字段的值
      // 例如 react.manifest.json 中就有 "name": "_dll_react"
      name: '_dll_[name]',
      // 描述动态链接库的 manifest.json 文件输出时的文件名称
      path: path.join(__dirname, 'dist', '[name].manifest.json'),
    }),
  ],
};
```
##### 使用动态链接库文件
构建出的动态链接库文件用于给其它地方使用，在这里也就是给执行入口使用。
用于输出 main.js 的主 Webpack 配置文件内容如下：

```javascript
const path = require('path');
const DllReferencePlugin = require('webpack/lib/DllReferencePlugin');

module.exports = {
  entry: {
    // 定义入口 Chunk
    main: './main.js'
  },
  output: {
    // 输出文件的名称
    filename: '[name].js',
    // 输出文件都放到 dist 目录下
    path: path.resolve(__dirname, 'dist'),
  },
  module: {
    rules: [
      {
        // 项目源码使用了 ES6 和 JSX 语法，需要使用 babel-loader 转换
        test: /\.js$/,
        use: ['babel-loader'],
        exclude: path.resolve(__dirname, 'node_modules'),
      },
    ]
  },
  plugins: [
    // 告诉 Webpack 使用了哪些动态链接库
    new DllReferencePlugin({
      // 描述 react 动态链接库的文件内容
      manifest: require('./dist/react.manifest.json'),
    }),
    new DllReferencePlugin({
      // 描述 polyfill 动态链接库的文件内容
      manifest: require('./dist/polyfill.manifest.json'),
    }),
  ],
  devtool: 'source-map'
};
```
#### tree-sheking webpack中配置的细节
> 剔除 JavaScript 中用不上的死代码, 依赖静态的 ES6 模块化语法

目前的 Tree Shaking 还有些的局限性，经实验发现：

1. 不会对entry入口文件做 Tree Shaking。 
2. 不会对异步分割出去的代码做 Tree Shaking。
#### 接入 Tree Shaking
首先，为了把采用 ES6 模块化的代码交给 Webpack，需要配置 Babel 让其保留 ES6 模块化语句，修改 .babelrc 文件为如下：
```javascript
{
  "presets": [
    [
      "env",
      {
        "modules": false // 关闭 Babel 的模块转换功能，保留原本的 ES6 模块化语法
      }
    ]
  ]
}
```
#### optimization.usedExports
> 用来标记已经使用的export, 默认是true,指出了哪些函数用上了哪些没用上

#### optimization.minimize
> 压缩 bundle, 剔除用不上的代码还得经过Terser处理, 代码就被剔除了

#### sideEffects配置(实现tree shaking: 移除 JavaScript 上下文中的未引用代码)
> 模块的副作用, 可以理解为引入了它但没有使用, webpack 默认不会清除这个模块, 因为不知道这个模块, 是否有用处, 比如使用了window对象, 引入了这个模块, 最好不要清除, 使用这个选项,能优化代码的体积, 但是使用时, 要小心, 不要剔除掉有用的代码了

- package.json文件中配置sideEffects
```javascript
sideEffects: false // 取消所有模块的副作用
sideEffects: [
    "./src/title.js",
  "*.css" // 也可以在webpack中配置
] // 只有title.js可以使用副作用
```

- optimization.sideEffects
> 默认是true, 辨识 package.json 中的 副作用 标记, 来跳过这些模块(当导出不被使用并且被标记不包含副作用的)。

#### CDN优化为什么把lodash放到CDN
lodash不用放CDN, 可以tree-shaking
#### 配置某些依赖不打包进bundle中
```javascript
externals: {
  vue: 'Vue',
  vuex: 'Vuex',
  'vue-router': 'VueRouter',
  axios: 'axios',
  echarts: 'echarts',
  vant: 'vant',
  'element-ui': 'ELEMENT',
  jspdf: 'jsPDF',
  vconsole: 'VConsole',
  VueLazyload: 'vue-lazyload'
},
```

#### 把cdn 注入到html模版中

- 修改HtmlWebpackPlugin插件选项
```javascript
// vue.config.js
module.exports = {
  chainWebpack: config => {
    config
      .plugin('html')
      .tap(args => { // 传递给 html-webpack-plugin's 构造函数的新参数
          args[0].cdn = {
            css: [`${CDN_BACE_URL}static/js/vant-2.8.css`, `${CDN_BACE_URL}static/js/element-ui-2.13.2.css`],
            js: [
              'https://res2.wx.qq.com/open/js/jweixin-1.6.0.js',
              `${CDN_BACE_URL}static/js/vue-2.6.11.js`,
              `${CDN_BACE_URL}static/js/axios-0.19.0.js`,
              `${CDN_BACE_URL}static/js/vuex-3.4.0.js`,
              `${CDN_BACE_URL}static/js/vue-router-3.3.2.js`,
              `${CDN_BACE_URL}static/js/echarts.min-4.7.0.js`,
              `${CDN_BACE_URL}static/js/vant.min-2.8.js`,
              `${CDN_BACE_URL}static/js/element-ui-2.13.2.js`,
              `${CDN_BACE_URL}static/js/jspdf-1.5.3.js`,
              `${CDN_BACE_URL}static/js/vconsole-3.3.4.js`,
              `${CDN_BACE_URL}static/js/vue-lazyload-1.3.3.js`
            ]
          };
          return args;
      })
  }
}

```

- HTML模版中使用
```javascript
<!DOCTYPE html>
<html lang="en" style="height: 100%">
  <head>
    <% for (var i in htmlWebpackPlugin.options.cdn&&htmlWebpackPlugin.options.cdn.css) { %>
    <link href="<%= htmlWebpackPlugin.options.cdn.css[i] %>" rel="preload" as="style" />
    <link href="<%= htmlWebpackPlugin.options.cdn.css[i] %>" rel="stylesheet" />
    <% } %> <% for (var i in htmlWebpackPlugin.options.cdn&&htmlWebpackPlugin.options.cdn.js) { %>
    <link href="<%= htmlWebpackPlugin.options.cdn.js[i] %>" rel="preload" as="script" />
    <% } %>
    <title></title>
  </head>
  <body>
    <% for (var i in htmlWebpackPlugin.options.cdn&&htmlWebpackPlugin.options.cdn.js) { %>
    <script src="<%= htmlWebpackPlugin.options.cdn.js[i] %>"></script>
    <% } %>
  </body>
</html>

```
#### splitChunks 怎么拆分

- 配置模块2次引用后,就拆分
- 设置模块拆分优先级 node_modules高于入口的chunks
```javascript
 optimization: {        
          splitChunks: {
            // 代码切割，公共代码提取
            cacheGroups: {
              // 缓存组可以继承和/或覆盖来自 splitChunks.* 的任何选项。但是 test、priority 和 reuseExistingChunk 只能在缓存组级别上进行配置。将它们设置为 false以禁用任何默认缓存组。
              common: {
                name: "common",
                chunks: "initial", //  是入口起点的 main chunk。此 chunk 包含为入口起点指定的所有模块及其依赖项。
                minChunks: 2, // 模块被引用次数
                priority: -20, // 优先级
                reuseExistingChunk: true, // 启动缓存组拆分
              },
              vendors: {
                test: /[\\/]node_modules[\\/]/,
                chunks: "all", // 所有的chunks中
                name: "vendors",
                minChunks: 2,
                priority: -10, // node_modules的拆分优先级高于入口的chunks
                reuseExistingChunk: true,
              },
            },
          },
        },
```

- 动态加载（按需加载）
主动使用import()来动态加载
#### 代码中性能优化的点有哪些

- 多用link、避免用@import
- 使用类选择器替代标签选择器
- 节流和防抖
- 减少DOM操作
- 使用事件委托
- 移动端单文件小于小于25k
#### 图片的预加载怎么做

- 隐藏在 css 的 background 的 url 属性里面

       可能有些默认图可以先盖住background

- 提前new Image 加载图片
#### 懒加载怎么做
使用HTML的data-xx存储图片的Src, 按需加载
根据浏览器的可视区域高度、浏览器滚动过的高度, 元素距文档顶部的距离加载
#### 有一批图片,需要先预加载出来, 并行和串行分别怎么做
并行
使用promise.all, 里面套所有图片的promise
串行
promise.then + async await
#### css优化 为什么要使用trasfrom替换position
主要是做动画的时候, 改变属性, 以下不同

- 改变transform或opacity不会触发浏览器重新布局（reflow）或重绘（repaint），只会触发合成（compositions）
- 改变绝对定位会触发重新布局，进而触发重绘和合成
#### vedio 一般初始化做什么, 一个页面有多个vedio,怎么做切换


初始化可以配置以下属性:

- preload 预加载资源
- x5内核 (X5内核视频在用户点击播放后默认会进入全屏播放)
1. 设置x5-video-player-type="h5-page",  标准的视频播放形态,  控制网页内部同层播放，可以在视频上方显示html元素

        2. x5-video-player-fullscreen='true'： 全屏设置,设置为 true 是防止横屏
       3. x5-video-player-orientation="portraint"  声明播放器支持的方向，横屏：landscape，竖屏：portraint

- playsinline="true" IOS微信浏览器支持小窗内播放, webkit-playsinline: webkit内联播放, x5-playsinline

为什么使用假全屏:
    1. ios全屏后, 视频播放会暂停
    2. 播放器播放的方向不是所有的手机都只是竖直屏幕
一个页面有多个vedio,怎么做切换:
1. 放多个vedio, 多个source
2. 切换到那个vedio, 就去播放
#### html2canvas压缩, 怎么保证它的清晰度
scale 大
#### 在做腾讯IM接入的时候, 有遇到怎么什么问题
消息丢包 用消息优先级, 保证关键信息不丢失
#### 说下react中的生命周期
       挂载: 
	constructor
        getDerivedStateFromProps
        render
componentDidMount
       更新:
    	getDerivedStateProps
	shouldComponentUpdate
render
        getSnapshotBeforeUpdate
componentDidUpdate
        卸载:
        componentWIllUnmount
#### 类组件父组件怎么调用子组件的方法, 几种方式
1. 使用ref获取组件实例
> 使用了HOC的子组件不可用，无法指向真是子组件

```javascript
// 类组件的ref使用
class Sub extends Component {
  callback() {
    console.log('执行回调');
  }
  render() {
    return <div>子组件</div>;
  }
}

class Super extends Component {
  constructor(props) {
    super(props);
    this.sub = React.createRef();
  }
  handleOnClick() {
    this.sub.callback();
  }
  render() {
    return (
      <div>
        // 第一种
        <Sub ref={this.sub}></Sub>
        // 第二种
        <Sub ref={ref => this.sub = ref}></Sub>

      </div>
    );
  }
}

```

2. 自定义props
>  需要自定义props属性
> 在父组件定义一个方法, 方法传一个参数, 是子组件的实例, 子组件调用这个方法, 并把this传进入

```javascript
lass Sub extends Component {
	componentDidMount(){
    // 将子组件指向父组件的变量
		this.props.onRef && this.props.onRef(this);
	}
	render(){
		return (<div>子组件</div>);
	}
}

class Super extends Component {
  constructor() {
    this.state = {
      Sub: null
    }
  }
	render(){
		return (
			<Sub onRef={ node => this.Sub = node }></Sub>	
    )
	}
}
```

3. 使用useImperativeHandle
> 需要自定义props属性, 需要自定义暴露的方法

```javascript
import React, { useImperativeHandle } from 'react';
import { observer } from 'mobx-react'


const Parent = () => {
  let ChildRef = React.createRef();

  function handleOnClick() {
    ChildRef.current.func();
  }

  return (
    <div>
      <button onClick={handleOnClick}>click</button>
      <Child onRef={ChildRef} />
    </div>
  );
};

const Child = observer(props => {
  //用useImperativeHandle暴露一些外部ref能访问的属性
  useImperativeHandle(props.onRef, () => {
    // 需要将暴露的接口返回出去
    return {
      func: func,
    };
  });
  function func() {
    console.log('执行我');
  }
  return <div>子组件</div>;
});

export default Parent;
```

4. 使用forwardRef
> withRouter、connect、Form.create等方法并不能抛出ref，假如Child本身就需要嵌套这些方法，那基本就不能混着用
> forwardRef本身也是用来抛出子元素，如input等原生元素的ref的，并不适合做组件ref抛出，因为组件的使用场景太复杂了

```javascript
import React, { useRef, useImperativeHandle } from 'react';
import ReactDOM from 'react-dom';
import { observer } from 'mobx-react'

// 抛出子元素
const FancyInput = React.forwardRef((props, ref) => {
  const inputRef = useRef();
  useImperativeHandle(ref, () => ({
    focus: () => {
      inputRef.current.focus();
    }
  }));

  return <input ref={inputRef} type="text" />
});

const Sub = observer(FancyInput)

const App = props => {
  const fancyInputRef = useRef();

  return (
    <div>
      <FancyInput ref={fancyInputRef} />
      <button
        onClick={() => fancyInputRef.current.focus()}
      >父组件调用子组件的 focus</button>
    </div>
  )
}

export default App;

```

#### 类组件组件复用的方式

- 高阶组件
> HOC 的本质是 接受组件作为参数，返回新组件的一个函数。

封装一个时间组件（ withTimer ），withTimer 只负责获取并更新时间的逻辑，在 UI 上展示的格式又 WrappedComponent 决定。
```javascript
import React from "react";

export default function withTimer(WrapperComponent) {
  return class extends React.Component {
    constructor(props) {
      super(props);
      this.state = {
        time: new Date(),
      };
    }
    componentDidMount() {
      this.timerID = setInterval(() => this.tick(), 1000);
    }
    componentWillUnmount() {
      clearInterval(this.timerID);
    }
    tick() {
      this.setState({
        time: new Date(),
      });
    }
    render() {
      return <WrapperComponent time={this.state.time} />;
    }
  };
}
```
```javascript
import React from "react";
import withTimer from "./withTimer";

export class OneComponent extends React.Component {
  // ...
  render() {
    renturn(<div>{this.props.time.toLocaleString()}</div>);
  }
}

export default withTimer(OneComponent);

```

- Render Props
> 函数作为子组件（this.props.children），也可以是其他任何函数 prop，例如 something prop（this.props.something）。

```javascript
<Mouse>
{(mouse) => (
    <p>
      鼠标的位置是 {mouse.x}，{mouse.y}
    </p>
)}
</Mouse>

<Mouse
  something={(mouse) => (
    <p>
      鼠标的位置是 {mouse.x}，{mouse.y}
    </p>
  )}
/>
```
children 是 React 组件的一个特殊内置属性，<Comp>xxx</Comp> 里的 xxx 部分会作为 children 传递给 Comp 组件，如果 xxx 是函数，那么 Comp 里主动调用它去得到结果。
```javascript
// 类组件的ref使用
class Sub extends Component {
  callback() {
    console.log('执行回调');
  }
  render() {
    return (<div>
      { this.props.children }
    </div>);
  }
}

class Super extends Component {
  constructor(props) {
    super(props);
  }
  render() {
    return (
      <div>
        <Sub>
          <p>
            这里是children的内容
          </p>
         </Sub>
      </div>
    );
  }
}

```
与 React.PureComponent 一起使用** React.PureComponent 中以浅层对比 prop 和 state 的方式来实现了 shouldComponentUpdate()**，在赋予 React 组件相同的 props 和 state 的情况下，React.PureComponent 可以提高性能。 但在**使用 render prop 时，浅比较 props 的时候总会得到 false，所以这会使 Pure.Component 失去优势。 **
#### 组件的props在哪里可以做监听, 怎么在生命周期中监听props的变化
使用getDerivedStateFromProps (获得从props中转化的state)
```javascript
// 当props发生变化后将值赋给当前组件的state变量
static getDerivedStateFromProps (nextProps, prevState) {
  return {
    curSth: nextProps.sth
  }
}
```
使用componentDidUpdate监听props变化
```javascript
componentDidUpdate(prevProps, prevState, snapshot) {
  if (this.props.userID !== prevProps.userID) {
    this.fetchData(this.props.userID);
  }
}

```
使用useEffect监听props变化
```javascript
useEffect(() => {
  console.log('userID更新了')
}, [props.userID]);
```
#### 有哪些hooks

- useState

作用：让函数型组件可以保存状态。
参数说明：

1. 接收的唯一参数即状态初始值，初始值可以是任意值。
2. 返回值为数组，存储为状态值和改变状态的方法，方法约定为set开头+状态名称。
3. 方法可以调用多次，保存不同的状态值。
4. 参数可以是一个函数，函数返回什么，初始状态就是什么，函数只会被调用一次，用在初始值是动态值的情况，如状态值是通过props获取的。
5. 设置状态值的方法的参数也可以是一个函数，它的返回值就状态值
6. 设置状态值的方法是异步的
```
const HelloWorld = () => {
    const [count, setCount] = useState(0)
    const [person, setPerson] = useState({name: 'jack'})

		// 当我们点击按钮时，document.title是jack，说用setPerson是异步
    const handlePerson = (state) => {
        setPerson(() => ({name: 'nono'}))
        document.title = person.name
    }
    return (
        <div>
            <p>{count}</p>
            <button onClick={() => {setCount(count + 1)}}>计数</button>
            <p>{person.name}</p>
            <button onClick={handlePerson}>改变人名</button>
        </div>
    )
}
```

- useReducer

是另一种让函数式组件可以保存状态的方法。个人理解，useReducer可以存储多种改变状态的方法，代码结构更加清晰。
```
const HelloWorld = () => {
    const reducer = (state, action) => {
        switch(action.type) {
            case 'increment': 
                return state + 1
            case 'decrement':
                return state - 1
            default:
                return state
        }
    }
    const [count, dispatch] = useReducer(reducer, 0)

    return (
        <div>
            <p>{count}</p>
            <button onClick={() => {dispatch({type: 'increment'})}}>加数</button>
            <button onClick={() => {dispatch({type: 'decrement'})}}>减数</button>
        </div>
    )
}
```

- useContext

在跨组件层级获取数据时，简化获取数据的代码
```
import React, {createContext, useContext} from "react";
// 创建一个countConText
const countContext = createContext()

const Foo = () => {
    const value = useContext(countContext)
    return (
        <div>
            {value.name}
        </div>
    )
}

const Child = () => {
    return (
        <div>
            <Foo />
        </div>
    )
}

const Parent = () => {
    return (
        <countContext.Provider value={{name: 'jack'}}>
            <Child />
        </countContext.Provider>
    )
}
```

- useEffect

useEffect是可以处理副作用的函数，类生命周期函数。可以把他看作componentDidMount/componentDidUpdate/componentWillUnMount的组合.
useEffect第二个参数的作用：

1. 当不设置第二个参数时，组件内只要有状态值改变，那么就会触发函数。
2. 当设置为空数组时，只有在首次渲染和卸载时才会触发。
3. 当数组中有状态值时，表示当状态值改变了，才会触发函数。

优点：

1. 可以按照用途把代码进行分类（将相关的业务逻辑归置到同一个副作用函数中）
2. 简化重复代码，使组件内部代码更加清晰
- useMemo

useMemo的行为非常类似Vue中的计算属性，可以检测某个值，根据变化的值计算新值。useMemo会缓存计算结果，如果检测的值没有发生变化，即使组件重新渲染，也不会重新计算。
```javascript
const HelloWorld = () => {
  const [count, setCount] = useState(0)
  const result = useMemo(() => {
    return count * 2
  }, [count])
  return (
    <div>
    <p>{count}</p> 
    <p>{result}</p>
    <button onClick={() => {setCount(count + 1)}}>计数</button>
  </div>
)
}
```
**react的memo方法**，直接复用最近一次渲染的结果, 仅**检查 props 变更**, 默认情况下其只会对**复杂对象做浅层对比**
当传入的**props**没有发生改变时，可以阻止组件更新，类似于PureComponent/shouldComponentUpdate (可以对state和props做**浅层对比**)
```javascript
const Foo = memo(function Foo () {
  console.log('我被重新渲染了')
  return (
    <div>123</div>
  )
})

const HelloWorld = () => {
  const [count, setCount] = useState(0)
  return (
    <div>
    <p>{count}</p>
    <button onClick={() => {setCount(count + 1)}}>计数</button>
  <Foo />
  </div>
)
}
```

- useCallback

性能优化，缓存函数，使组件重新渲染时得到相同的函数实例
> 可以避免非必要的子组件渲染,  假设父组件重新渲染了, 它的方法也会重新初始化, 这个方法又通过props传递给子组件, 子组件就会重新渲染 (其实没必要)

```javascript
const UseCallbackComponent = () => {
  const [count, setCount] = useState(0)

  const change = useCallback(() => {
    console.log('child按钮被点击了！')
  }, [setCount]) // 依赖项改变了, 才会重新更新这个函数
  return (
    <div>
    <h1>useCallback</h1>
    <p>{count}</p>
    <button onClick={() => setCount(count + 1)}>按钮</button>
  <Child change={change} />
  </div>
)
}

const Child = memo((props) => {

  useEffect(() => {
    console.log('Child组件被刷新了')
  })

  return (
    <div>
      <button onClick={(e) => props.change(e)}>child按钮</button>
    </div>
  )
})
```

- useRef
1. **获取dom元素**对象的，得到的是包含一个叫current属性的对象，current就是对应的dom对象。
```javascript
const HelloWorld = () => {
  const dom = useRef()
  return (
    <div ref={dom}>
    <button onClick={() => console.log(dom)}>获取元素</button>
    </div>
  )
}
```

2. **保存数据**，即使组件重新渲染，保存的数据仍然还在，**保存的数据被更改不会触发组件的渲染**。
```javascript
const HelloWorld = () => {
  const [count, setCount] = useState(0)
  const timeId = useRef()
  useEffect(() => {
    timeId.current = setInterval(() => {
      setCount((count) => count + 1)
    }, 1000)
  }, [])

  const stopCount = () => {
    clearInterval(timeId.current)
  }
  return (
    <div>
    <p>{count}</p>
    <button onClick={stopCount}>停止计数</button>
    </div>
  )
}
```

#### 怎么自定义一个hooks, 具体什么场景去需要自定义hooks, 异步请求有没有必要定义hooks

- 自定义 Hook 约定必须以 “use” 开头的函数
- 函数内部可以调用其他的 Hook
- 参数和返回值没有要求, 默认返回一个undefined
- 场景
UI交互、副作用、生命周期、数据处理、DOM处理、优化处理等
#### 说下 react diff 对比
三定律

- 忽略节点跨层级操作场景，提升比对效率。(react diff是对DOM树的比较, 同层树的对比)
- 两个不同类型的元素会产生出不同的树，就是如果层级上的元素类型不同，那么也不会继续diff下面的节点
- key属性可以用来优化, 通过元素的 key 值来判断该元素是否已经存在？是否需要创建？是否需要移动位置？从而减少不必要的元素渲染
#### 说下服务端渲染, 同构? 说下asyncdata 是什么样的函数

-  客户端渲染 
   - 前后分离的前端
-  服务端渲染 
   - 以前的PHP直接用模版引擎组装html,再返回到客户端
-  同构渲染 
   -  同样一套代码, 既可以运行在服务端也可以运行在客户端 
   -  服务端渲染整个页面 
   -  客户端渲染 
      - 在html中提取服务器发送过来的数据,用来初始化整个Vue.js(事件绑定这些)
      - 把已经渲染的DOM元素和vue组件渲染的虚拟DOM建立联系
- Vue：Nuxt.js
- React：Next.js
- asyncdata 用来请求数据, 它是一个静态函数
#### css 实现三角形
CSS绘制三角形主要用到的是border属性，也就是边框。

平时在给盒子设置边框时，往往都设置很窄，就可能误以为边框是由矩形组成的。实际上，border属性是右三角形组成的，下面看一个例子：
```css
div {
    width: 0;
    height: 0;
    border: 100px solid;
    border-color: orange blue red green;
}
```
将元素的长宽都设置为0，显示出来的效果是这样的：
![](https://cdn.nlark.com/yuque/0/2020/png/1500604/1603636245125-d60dca78-0577-4aa1-8809-f1d38594889a.png#align=left&display=inline&height=298&margin=%5Bobject%20Object%5D&originHeight=502&originWidth=1012&size=0&status=done&style=stroke&width=600#averageHue=%23fbe3d8&height=248&id=qVBLM&originHeight=502&originWidth=1012&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&title=&width=500)
所以可以根据border这个特性来绘制三角形：
**（1）三角1**
```css
div {
    width: 0;
    height: 0;
    border-top: 50px solid red;
    border-right: 50px solid transparent;
    border-left: 50px solid transparent;
}
```
![](https://cdn.nlark.com/yuque/0/2020/png/1500604/1603636245420-28c28277-5074-4725-9386-ffc955cf950a.png#align=left&display=inline&height=132&margin=%5Bobject%20Object%5D&originHeight=162&originWidth=738&size=0&status=done&style=stroke&width=600#averageHue=%23fdedec&height=110&id=ikJAG&originHeight=162&originWidth=738&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&title=&width=500)
**（2）三角2**
```css
div {
    width: 0;
    height: 0;
    border-bottom: 50px solid red;
    border-right: 50px solid transparent;
    border-left: 50px solid transparent;
}
```
![](https://cdn.nlark.com/yuque/0/2020/png/1500604/1603636245172-36f955bd-075b-442a-b88b-6c084c66ed25.png#align=left&display=inline&height=133&margin=%5Bobject%20Object%5D&originHeight=140&originWidth=630&size=0&status=done&style=stroke&width=600#averageHue=%23fce7e6&height=111&id=uuoZE&originHeight=140&originWidth=630&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&title=&width=500)
**（3）三角3**
```css
div {
    width: 0;
    height: 0;
    border-left: 50px solid red;
    border-top: 50px solid transparent;
    border-bottom: 50px solid transparent;
}
```
![](https://cdn.nlark.com/yuque/0/2020/png/1500604/1603636245082-84a06746-dfc7-4782-a0d4-27d521aecac7.png#align=left&display=inline&height=195&margin=%5Bobject%20Object%5D&originHeight=210&originWidth=646&size=0&status=done&style=stroke&width=600#averageHue=%23fdefee&height=163&id=ydY41&originHeight=210&originWidth=646&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&title=&width=500)
**（4）三角4**
```css
div {
    width: 0;
    height: 0;
    border-right: 50px solid red;
    border-top: 50px solid transparent;
    border-bottom: 50px solid transparent;
}
```
![](https://cdn.nlark.com/yuque/0/2020/png/1500604/1603636245064-ecd01197-99fc-476e-897f-a4165b55792a.png#align=left&display=inline&height=191&margin=%5Bobject%20Object%5D&originHeight=220&originWidth=690&size=0&status=done&style=stroke&width=600#averageHue=%23fdf1f0&height=159&id=vve1R&originHeight=220&originWidth=690&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&title=&width=500)
**（5）三角5**
```css
div {
    width: 0;
    height: 0;
    border-top: 100px solid red;
    border-right: 100px solid transparent;
}
```
![](https://cdn.nlark.com/yuque/0/2020/png/1500604/1603636245095-5b40d585-7e68-4bb0-aaef-6c8fce7d36b8.png#align=left&display=inline&height=177&margin=%5Bobject%20Object%5D&originHeight=218&originWidth=738&size=0&status=done&style=stroke&width=600#averageHue=%23fce5e3&height=148&id=p054c&originHeight=218&originWidth=738&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&title=&width=500)
还有很多，就不一一实现了，总体的原则就是通过上下左右边框来控制三角形的方向，用边框的宽度比来控制三角形的角度。
#### css 实现梯形

- 高度为0, width固定, 再配置border部分边的transparent, 和实心边
```javascript
<div class="trapezoid"></div>
```
（1）实现一个直角梯形：
```css
.trapezoid {
    height: 0;
    width: 100px;
    border-bottom: 100px solid red;
    border-right: 40px solid transparent;
}
```
效果：
![image.png](https://cdn.nlark.com/yuque/0/2021/png/1500604/1630773730069-a1bf7073-14ba-4665-9e5e-cf0aa0722235.png#averageHue=%23f17a6f&clientId=u9e96075e-ac11-4&errorMessage=unknown%20error&from=paste&height=141&id=u2be68814&name=image.png&originHeight=282&originWidth=408&originalType=binary&ratio=1&rotation=0&showTitle=false&size=4586&status=error&style=shadow&taskId=uaa930c1f-4401-452c-bf61-fb7910f2d6d&title=&width=204)
（2）实现一个等腰梯形
```css
.trapezoid {
  height:0;
  width:100px;
  border-width:0 40px 100px 40px;
  border-style:none solid solid;
  border-color:transparent transparent red;
}
```
效果：
![image.png](https://cdn.nlark.com/yuque/0/2021/png/1500604/1630773825580-c1821c13-4513-4462-9a13-73ad4a3ef6e6.png#averageHue=%23f17b71&clientId=u9e96075e-ac11-4&errorMessage=unknown%20error&from=paste&height=139&id=uf7a86877&name=image.png&originHeight=278&originWidth=490&originalType=binary&ratio=1&rotation=0&showTitle=false&size=5905&status=error&style=shadow&taskId=u84c3800b-cbde-4be8-be7a-e1abdc38d36&title=&width=245)

- 使用长方形+transfrom: rolate() 旋转一个角度
#### css 实现两列布局 flex 一边没有高度 怎么撑开
```javascript
 <!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
    <style type="text/css">
      .container{
        display: flex;
        flex-flow: row nowrap;
        width: 700px;
      }
      .container__left {
        width: 200px;
        background-color: red;
      }
      .container__right {
         flex: 1;
         height: 300px;
         background-color: black;
      }
    </style>
</head>
<body>
    <div class="container">
        <div class="container__left">左边</div>
        <div class="container__right">右边</div>
    </div>
</body>
</html>
```
#### 自己对前端感兴趣的地方是哪些
webRTC
### 二面( 交叉面)
第一个面试官针对简历上项目问，没有涉及具体技术
第二个面试官
一个多边形，元素点击，判断是在多边形内还是外
动画做得多吗 在项目中怎么做动画的
一个组件库，依赖在项目中，组件库是个url 怎么自动监控到组件变化，重新编译项目
服务端渲染有具体做过吗 服务器端压力太大怎么办
有没有做过组件库
Vue和React怎么做组件通讯
组件怎么做复用
Nodejs有什么经验吗
写过什么webpack loader 和插件吗
发版后，缓存怎么解决
对携程了解吗
平时有什么爱好
打不打游戏
### 英语口语测试
[https://liuliuliu.yuque.com/wangweiming-cc9sl/bfkd0z/frpw1s](https://liuliuliu.yuque.com/wangweiming-cc9sl/bfkd0z/frpw1s)

### 在线测评 (公务员)
[https://liuliuliu.yuque.com/wangweiming-cc9sl/bfkd0z/tsatko](https://liuliuliu.yuque.com/wangweiming-cc9sl/bfkd0z/tsatko)
### Hr面
> 待定

##  恰太
### 一面

- vue nexttick用法和实现
- 说下vue diff算法
- 说下vue2的响应式原理
- 发布订阅模式和观察者模式的区别
- computed和watch的区别
- vue-router路由的方法的方法 query params 区别
- 说说vue 组件间通讯
- keep-alive用法 作用
- 指令的写法, 具体怎么用到项目
- 浏览器的垃圾回收机制
- 小程序怎么绑定事件, 和传参数
- 是否了解小程序的热编译和冷编译
- 怎么减少包的体积大小, 怎么分包
- 在做实时音视频的时候, 有遇到怎么问题, 怎么处理的
- 怎么做小程序的性能优化
- 小程序和vue的区别
## 阿维塔科技
### 一面

- react 父组件怎么调用子组件的方法
#### 说下useCallback
性能优化，缓存函数，使组件重新渲染时得到相同的函数实例
> 可以避免非必要的子组件渲染,  假设父组件重新渲染了, 它的方法也会重新初始化, 这个方法又通过props传递给子组件, 子组件就会重新渲染 (其实没必要)

```javascript
const UseCallbackComponent = () => {
  const [count, setCount] = useState(0)

  const change = useCallback(() => {
    console.log('child按钮被点击了！')
  }, [setCount]) // 依赖项改变了, 才会重新更新这个函数
  return (
    <div>
    <h1>useCallback</h1>
    <p>{count}</p>
    <button onClick={() => setCount(count + 1)}>按钮</button>
  <Child change={change} />
  </div>
)
}

const Child = memo((props) => {

  useEffect(() => {
    console.log('Child组件被刷新了')
  })

  return (
    <div>
      <button onClick={(e) => props.change(e)}>child按钮</button>
    </div>
  )
})
```
#### 说下useMemo
useMemo的行为非常类似Vue中的计算属性，可以检测某个值，根据变化的值计算新值。useMemo会缓存计算结果，如果检测的值没有发生变化，即使组件重新渲染，也不会重新计算。
```javascript
const HelloWorld = () => {
  const [count, setCount] = useState(0)
  const result = useMemo(() => {
    return count * 2
  }, [count])
  return (
    <div>
    <p>{count}</p> 
    <p>{result}</p>
    <button onClick={() => {setCount(count + 1)}}>计数</button>
  </div>
)
}
```
#### 说下React.memo
直接复用最近一次渲染的结果, 仅**检查 props 变更**, 默认情况下其只会对**复杂对象做浅层对比**
当传入的**props**没有发生改变时，可以阻止组件更新，类似于PureComponent/shouldComponentUpdate (可以对state和props做**浅层对比**)
```javascript
const Foo = memo(function Foo () {
  console.log('我被重新渲染了')
  return (
    <div>123</div>
  )
})

const HelloWorld = () => {
  const [count, setCount] = useState(0)
  return (
    <div>
    <p>{count}</p>
    <button onClick={() => {setCount(count + 1)}}>计数</button>
  <Foo />
  </div>
)
}
```
#### 什么是vue的composition api, 作用

-  动机 
   - 在组件之间复用状态逻辑很难
   - 复杂组件变得难以理解
   - minix 与组件之间存在隐式依赖，可能产生冲突。
   - 高阶组件 多层包裹嵌套组件，增加了复杂度和理解成本
   - Render Props 使用繁琐，不好维护, 代码体积过大，同样容易嵌套过深
-  优点 
   - 相同逻辑代码的复用
   - 减小了代码体积
   - 没有 this 的烦恼
-  setup 
   -  在组件被创建之前，props 被解析之后执行 
      - 晚于 beforeCreate 钩子，早于 created 钩子被调用
   -  入参: props、context 
   -  类型推断 
      - defineComponent
-  生命周期钩子 
   -  onX函数 
      - onMounted onUpdated onUnmounted
-  provide 和 inject 启用依赖注入 
-  getCurrentInstance 支持访问内部组件实例。 
#### javascript中怎么让一个对象不能添加属性
```javascript
let a = {
  b: 1
} // 让a无法再添加属性
```

- Object.preventExtensions
> 让一个对象变的不可扩展，也就是永远不能再添加新的属性

- Object.seal()
> Object.seal()方法封闭一个对象，阻止添加新属性并将所有现有属性标记为不可配置。当前属性的值只要原来是可写的就可以改变。

- Object.freeze()
> 现有属性值是不可变的

#### 手写一个数组拍平
![“original_5326493f52b173612d4bd19dab542097”的副本 2.png](https://cdn.nlark.com/yuque/0/2022/png/1184187/1660216785980-bf72139c-57ea-47d3-8d31-0f9604339a12.png#averageHue=%23fcfcfc&clientId=u1a4a34e0-acf6-4&errorMessage=unknown%20error&from=paste&height=656&id=u290e2789&name=%E2%80%9Coriginal_5326493f52b173612d4bd19dab542097%E2%80%9D%E7%9A%84%E5%89%AF%E6%9C%AC%202.png&originHeight=1312&originWidth=972&originalType=binary&ratio=1&rotation=0&showTitle=false&size=129478&status=error&style=none&taskId=ue7822967-cd74-4a9f-aed4-1b8256d9e62&title=&width=486)
```javascript
function flat(arr) {
	let result = []
	for(let i= 0; i < arr.length; i++) {
		if(arr[i].children) {
			result.push({
				id: arr[i].id,
				name: arr[i].name,
			})
			result = result.concat(flat(arr[i].children))
		} else {
			result.push({
				id: arr[i].id,
				name: arr[i].name,
			})
		}
	}
	return result
}
const data =[
	{
		id: 1,
		name:'test1',
		children:[
			{
				id:11,
				name:'test11', 
				children: [
					{ id:111, name:'test111'},
					{ id:112, name:'test112'},
				],
			}
		],
	},
	{
		id:2,
		name:'test2',
		children:[
			{
				id:21,
				name:'test21'
			}
		],
	},
]
	
console.log(JSON.stringify(flat(data)))
/**
*[
{ "id": 111, "name":"test111" }{ "id": 112, "name": "test112" },{ "id": 11, "name":"test11" }.{ "id": 1, "name":"test1" },{ "id": 21, "name":"test21" },{ "id": 2, "name":"test2" }
]
*/

```
#### 手写以下布局
![original_3e9ba7def91945c09ea0a76b6954b7fc.png](https://cdn.nlark.com/yuque/0/2022/png/1184187/1660216886549-e7cf1d41-9c89-468f-9f7b-5e30fe1a97d0.png#averageHue=%23f9fcfb&clientId=u1a4a34e0-acf6-4&errorMessage=unknown%20error&from=paste&height=342&id=u59c45f63&name=original_3e9ba7def91945c09ea0a76b6954b7fc.png&originHeight=684&originWidth=1504&originalType=binary&ratio=1&rotation=0&showTitle=false&size=33351&status=error&style=none&taskId=udf5637e4-f389-422c-8c9d-f1be4cf6351&title=&width=752)
```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
    <style type="text/css">
      .container{
        height: 100vh;
        width: 100vw;
        display: flex;
        flex-flow: row nowrap;
      }
      .container__left {
        width: 70%;
        height: 100%;
        display: flex;
        flex-flow: column nowrap;
      }
      .wrapper {
        display: flex;
        flex-flow: row nowrap;
        flex: 1;
        width: 100%;
      }
      .box-red {
        flex: 4;
        background-color: red;
      }
      .box-blue, .box-cheng {
        flex: 1;
      }
      .box-blue {
        background: blue;
      }
      .box-cheng {
        background-color: #4767bc;
      }
      .container__right {
        width: 30%;
        height: 100%;
        display: flex;
        flex-flow: column nowrap;
      }
      .box-cheng2 {
        flex: 1;
        background-color: #000;
      }
      .box-zi {
        flex: 4;
        background-color: #dfe;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <div class="container__left">
        <div class="box-red"></div>
        <div class="wrapper">
          <div class="box-blue"></div>
          <div class="box-cheng"></div>
        </div>
      </div>
      <div class="container__right">
        <div class="box-cheng2"></div>
        <div class="box-zi"></div>
      </div>
    </div>
  </body>
</html>
```
## 叠纸游戏
### 一面

1. {} == {}

`false`等于号==的转换规则如下

   - 两个都为简单类型，Number,Boolean,String,Undefined都会转换成**数值**，再比较，Undefined转为数字是NAN
   - 简单类型与引用类型比较，对象转化成其原始类型的值调用**valueOf与toString**，再比较
   - 两个都为引用类型，则比较它们是否指向同一个对象
   - null 和 undefined 相等
   - 存在 NaN 则返回 false
2. vue2到vue3做了哪些升级

变化：composition API，framents，更好的ts支持
编译优化

   - diff算法优化：vue3中在改变的位置添加标记，比较能跳过静态代码位置
   - 静态提升：静态提升，静态只做一次编译
   - 事件监听缓存
   - SSR优化

源码体积减少

   - 移除不常用的api如： 过滤器
   - 更好的tree-shaking：没有使用的api不会打包如：v-model，keep-alive

响应式系统

   - 可以监听动态属性的添加
   - 可以监听到数组的索引和数组length属性
   - 可以监听删除属性
   - proxy可以拦截访问，赋值，删除， 不需要一开始就遍历所有属性，在访问属性的时候才处理下一级属性
3. js基础数据类型，和引用类型的区别

（基本类型5种）number、string、boolean、null、undefined 。 栈存储
（引用类型1种） object  堆存储

4. const arr = [], 长度是可以变化的么？ 输出：arr.push(0)   arr = []

可变化长度 const 引用类型，限制指针不可修改 

5. 聊一聊 Cookies, Storage

均为本地存储， 从数据大小、有效时间切入异同点
```javascript
    if(!a && !b){}
    else if(!a && b){}
    else (a && !b){}

```

6. 说说以上代码优化

提前return； if判断多的可以使用switch case语意清晰

7. 聊聊递归，和尾递归优化

递归，调用自身
尾递归：函数中所有递归形式的调用都出现在函数的末尾，对于尾递归来说，由于只存在一个调用记录，所以永远不会发生"栈溢出"错误
```json
function factorial(n) {
  if (n === 1) return 1;
  return n * factorial(n - 1); // 非尾递归，因为最后一步指令是*
}

factorial(5) // 120
```

8. 操作：一个正方形图片，固定右上角，拖动左下角使之旋转一定角度  求：这个角度是多少？
9. 浏览器怎么起多线程

web worker ， service worker

10. 介绍一下pixijs，pixijs支持离屏渲染么？
11. 6万个精灵需要渲染在canvas上，怎么做优化？
   - 离开屏渲染，一次绘入
   - 隐藏不需要的对象
   - 静态和批次，不需要运动的对象
12. 怎么触发GPU渲染

transform，will-change

13. WebGL vs canvas 2D
14. nodejs使用，使用过哪些
15. http状态码
| 200 | 请求成功 |
| --- | --- |
| 301 | 永久重定向 |
| 302 | 临时重定向 |
| 304 | 协商缓存 |
| 400 | 请求语法出错 |
| 403 | 服务器拒绝请求，没有权限 |
| 404 | 找不到资源 |
| 500 | 服务器内部错误 |

16. 设计一个列表组件，列表数据可拖拽，说一下设计思路与实现
17. 离职原因
18. 对叠纸游戏有了解么
19. 为什么想投叠纸游戏？
### 二面

1. 介绍一下之前的工作经历
2. 有一个需要几年的长期维护项目，开发角度怎么保证持续迭代，可维护性
   1. 代码规范为前提，lint相关，ts
   2. 设计方案评审
   3. 定期整理回顾 review
3. 项目沉淀整理，review都需要时间，怎么平衡技术成本，和业务成本
4. canvas内物体的宽高设置和页面宽高，不一致，怎么处理响应式兼容

根据媒体查询/js窗口resize监听，整体缩放canvas

5. 现在的自我定位和未来的规划
6. 在canvas上实现帧动画播放，写出伪代码
```json
1. 获取<canvas></canvas>
2. ctx = getContent('2d')
3. img
4. onlad function
5. 图片信息，
6. 每个小鸟位置信息,6只
7. ctx.drawimage(图片, 0， 0， w,h,0,0,w,h)

循环setinterval(()=>{
  index++
  ctx.clearRect(0,0,canvasW,canvasH)
  ctx.drawimage(图片, 0， 0， w,h,0,0,w,h)
  if(index >= 6) {
    index = 0
  }
},300)
```

7. 代码实现 发布订阅类
## 数坤
### 一面

1. 项目问题。。
2. target 和  currentTarge区别

target事件触发目标元素
currentTarge事件绑定元素

3. css的定位属性有哪些，各属性相对于什么元素进行定位
4. 聊聊js模块化
5. ESM 和 CommonJS 区别
6. 如何拍平二维数组

flat

7. weakMap 有了解么

WeakMp特点

   1. WeakMap 只接受对象作为键名
   2. WeakMap 的键名所引用的对象是弱引用
   3. 因为是弱引用，所以key值不可遍历
8. 设计题：需要做 悔棋 功能，怎么实现

使用栈数据结构实现
### 二面

1. 离职原因
2. 之后规划是怎么样的，为什么想换一个行业领域
3. 介绍（详细）一个项目，选型
4. 项目角色
5. 项目亮点
6. arrybuff 和 数组有什么区别

固定长度，二进制数据流

7. js的数组是可以扩展的，是怎么实现的

先分配一个小的数组，不够用再 建一个大的，将之前的内容拷贝过去

8. eventloop
9. es6 的 let 和 var 区别
10. 时间复杂度是
11. 常见排序时间复杂度![sort.png](https://cdn.nlark.com/yuque/0/2022/png/25708943/1659950586060-a3289cc4-ea77-45b0-ae49-6665cb5d0c9b.png#averageHue=%23e5dfd8&clientId=ua09550a2-5244-4&errorMessage=unknown%20error&from=drop&id=u351ba7b7&name=sort.png&originHeight=588&originWidth=966&originalType=binary&ratio=1&rotation=0&showTitle=false&size=25092&status=error&style=none&taskId=ue0d3ac4a-02ec-402c-9c73-e0937affcfb&title=)
12. 最差的快排时间为什么是 On2
13. 浏览器输入网址到现实，大概流程
- url 解析
- dns 域名解析
   -  查找浏览器缓存
   - 查找系统缓存
   - 查找路由缓存
   - 家产 ISP 服务商的 DNS 缓存
   - 从根域名服务器递归查询 IP
- TCP 链接（3 次握手，TLS7 次）
- 请求和传输数据
- [浏览器渲染页面](#vEnu1)
- 关闭链接
14. 浏览器调优分析
- Performance
## 酷家乐：
### 一面

1. 你们项目权限管理是怎么做的
2. 聊一聊自定义权限指令怎么做
3. 项目中有哪些角色权限
4. axios 二次封装请求返回怎么做的
5. 怎么处理token超时
6. IntersectionObserver 场景和使用
7. 错误监控系统，监控哪方面的错误
8. 埋点指标
9. ts经常使用的功能
10. 常用优化资源加载方式
11. vue如果做响应式
12. vue 不会立刻更新，如何更新呢
13. nexttick本质做了什么
14. vue 写样式 scope原理有了解么
15. deep 有了解过么
16. vue 通行方式
17. vuex 原理
18. promise 作用，状态，方法
19. promise.all 如果其中有一个错误，返回的是什么
20. 聊聊async / await
21. 箭头函数 和 普通函数的区别，箭头函数this指向哪里
22. var let const 区别
23. 对象遍历的方法
24. for in 和 for of区别
25. 怎么区分是否是对象原型上的方法，还是自身的
26. js怎么做类型判读呐
27. Object.prototype.toString.call 为什么能拿到原始对象类型
28. es5 原型链
29. 离职原因
30. 对下家公司的期望

## 乐府互娱
### 一面

1. 响应式设计的基本原理
2. 预编译器，看法和了解
3. 0.1 + 0.2 == 0.3?
4. 数组的遍历方式，有哪些
5. js数组遍历性能排序，执行速度
6. 聊一聊，性能优化
7. 减少首屏加载时间
8. 运维 加载首屏优化处理
9. 虚拟dom原理： [https://juejin.cn/post/6844903902429577229#heading-1](https://juejin.cn/post/6844903902429577229#heading-1)
10. 做了什么组件
11. ui组件库的管理，npm？
12. 设计一个轮播组件，不使用swiper
13. 10个球，有一个重，称几次找到重球
14. 项目中印象深刻的问题，解决思路过程
15. 平时浏览的技术网站
## 华为OD
### 笔试题

1. 字符串转换，规则：字符串第一位ascii值+1， 第二位+2， 第三位+3，..第n位，偏移为n = 【n-1】+【n-2】+【n-3】 给定字符串长度 大于0 小于50， 任意给定字符串求转换后的字符串

如：x --> y
xy--> ya

2. 种树题 [https://leetcode.cn/circle/discuss/VJzqF3/](https://leetcode.cn/circle/discuss/VJzqF3/)
3. F, M, M, F
F, M ,M, F
F, F,  F,  M   如左边队列，M为男生，求该队列中最大男生连线（横向，竖向，斜向）数量，本示例最大连线数量为3
## 蔚来
### 一面
> 都是针对项目提问的，没有常见基础题如下：

桌游卡牌系统，前端状态逻辑怎么设计
游戏框架结构描述
UI组件库怎么设计

## 鹰角网络
### 一面
#### 描述浏览器打开下面一段html代码能看到的内容
```html
<div>a</div>
<script>alert('xxx')</script>
<div>b</div>
```
浏览器逐行解析，读到script会直接执行js，会打断解析过程，页面就不会渲染，故不会显示内容，只有alert
#### 浏览器解析文档是什么过程
####  eventloop
#### 代码实现 树状化数据，请实现arrToTree方法
```json
const src = [
  {id:3,parentId:2},
  {id:2,parentId:1},
  {id:1},
  {id:4},
  {id:5,parentId:4},
  {id:6,parentId:8}
]
const arrToTree = (arr) => {

}

const dest = arrToTree(src)
console.log(dest);

// [
//   {
//			id:1,
//			children:[
//				{
//					id:2,
//					parentId:1,
//					children:[{id:3,parentId:2}]
//				}
//			]
//    }
// ]
```
#### 优化资源加载怎么实现，有没有别的方案，调研过程
按需加载，分图集； 压缩图片；zip；利用文件系统进行资源缓存；
 其他方案：service worker 
调研：网上找案例，身边找朋友  做demo
#### 工程化优化，webpack上做的哪些优化
构建优化

-  配置缓存，loader: 'babel-loader?cacheDirectory=true'，其他用cache-loader / HardSourceWebpackPlugin， webpack5已经自带了
- 对于loader，用include和exclude控制需要转义的范围
- 使用thread-loader，happypack，开启多进程编译 

打包优化

- JS代码压缩
- CSS代码压缩
- Html文件代码压缩
- 图片压缩
- Tree Shaking
#### webpack新版本 动态引入
#### webpack打成不同chunk跨文件函数方法调用是怎么做的
#### webpack require 实现
####  gulp 和 webpack 选型是怎么考虑的？
#### 面向C端页面加载优化

- webpack打包优化
- 懒加载
- gzip
####  重流重绘优化措施

- 元素脱离文档
- 样式批量改变
#### 响应式怎么做
rem 
#### 复用业务代码，会怎么做
组件库
